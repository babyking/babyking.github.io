---
typora-root-url: ../
typora-copy-images-to: ../image
layout: page 
title: 一个人的推
permalink: /t/
date: 2019-09-23 11:46
---

前言
说是前言，其实也是本文诞生的目的。随着公司业务的不断增加，功能的快速迭代，app的业务线越来越多，代码体积变得越来越庞大。同时，app投入的开发者也也越来越多，不同的开发者的code风格千差万别。加之公司开发者人员变动，为了保证app稳定性，保证开发效率，统一开发风格。于是，这篇iOS开发规范应运而生。
因笔者现在所就职公司的开发规范主导编写，目前公司业务的迭代都在按照这个规范在有条不紊的进行。综合之前编写规范的经验，历时一个月的时间，断断续续重新梳理了一份比较全面、比较完整的iOS开发者规范，希望这些条条框框能够给正在阅读的你提供一些参考的价值。也希望越来越多的iOS开发者能够养成优秀的编码习惯。如果你觉得个别地方不妥或者有需要补充的规范，请留言或者私信，我会第一时间响应。

约定
在我看来，开发规范像是一条可供参考的标准线。不同开发者可以根据这条标准线来规范自己的开发行为，尤其是在大的项目中，开发规范可以约束不同开发者的开发风格，使项目从细节到整体上都能达到风格统一，利于维护。
本文的开发规范由很多item组成，不同的item描述了不同的问题。每一个item就是一条具体的开发规范，违反不同的开发规范，也会引起不同严重程度的后果。就像法律和道德的差异一样，我们必须遵守法律，不然可能带来损人不利己的严重后果，但有些人虽然没有触犯法律，却违背了道德，虽然暂时没有产生严重的后果，长此以往，也会形成一种坏的风气。所以，无论法律和道德，我们都该鞭策自己成为优秀的人，而不该止步于一个合格的人。同理，开发规范也是如此，我们必须遵守那些必须要遵守的开发规范，提倡遵守那些建议你遵守的开发规范。所以，根据约束力度，我们把开发规范暂时划分成两个等级，分别是【必须】、【建议】。

【必须】：必须遵守。是不得不遵守的约定，一旦违反极有可能引起严重后果。
【建议】：建议遵守。长期遵守这样的约定，有助于维护系统的稳定和提高合作效率。
本文参考了苹果官方编码指南和github上一些知名的编码规范，也算是取众人之所长，集百家之精华的一篇文章。读者可以根据自己的实际需要和兴趣点来选择性的阅读。本文主题部分主要由以下两章(共32节)构成：
(一) 命名规范

通用命名规范(讲述命名的一些通用规范)
缩写规范(讲述常见的缩写以及缩写规范)
Method命名规范(讲述方法命名的具体规范)
Accessor命名规范(讲述set和get方法的命名规范)
Parameter命名规范(讲述参数命名规范)
Delegate方法命名规范(讲述delegate方法的命名规范)
Private方法命名规范(讲述私有方法的命名规范)
Category命名规范(讲述分类的命名规范)
Class命名规范(讲述类命名规范)
Protocol命名规范(讲述协议的命名规范)
Notification命名规范(讲述通知的命名规范)
Constant命名规范(讲述枚举常量以及const常量的命名规范)
Exception命名规范(讲述异常的命名规范)
(二)编码规范

Initialize方法(讲述类的initialize方法的使用规范)
Init方法(讲述初始化方法的设计规范包括designated init方法和secondary init方法)
Init error(讲述init方法初始化对象失败时的错误处理)
Dealloc规范(讲述dealloc方法的使用规范)
Block规范(讲述block的使用规范)
Notification规范(讲述通知的使用规范)
UI规范(讲述开发UI时的一些规范)
IO规范(讲述读写文件时的一些注意事项)
Collection规范(讲述集合类型的使用规范)
分支语句规范(讲述常用的分支语句if、switch语句的编码规范)
对象判等规范(讲述常用的判定对象等同性的方法使用规范)
懒加载规范(讲述懒加载的使用规范)
多线程规范(讲述多线程环境下的一些编码规范)
内存管理规范(讲述编码过程中常见的内存管理注意点)
延迟调用规范(讲述使用延迟方法时注意事项)
注释规范(讲述编码中注释的使用规范)
类的设计规范(讲述类的设计规范)
代码组织规范(讲述类中的代码组织规范)
工程结构规范(讲述工程的文件组织规范)
(一)命名规范
根据Cocoa编码规范里的描述，以前情况下，命名应该遵循以下基本原则：Clarity、Consistency、No Self Reference。即清晰性、一致性、不要自我指涉Code Naming Basics。

(1.1) 通用命名规则
一般情况下，通用命名规则适用于变量、常量、属性、参数、方法、函数等。当然也有例外，下面我们会针对于每一种情况一一列举。
【必须】自我描述性。属性/函数/参数/变量/常量/宏 的命名必须具有自我描述性。杜绝中文拼音、过度缩写、或者无意义的命名方式。

【必须】禁止自我指涉。属性/局部变量/成员变量不要自我指涉。通知和掩码常量(通常指那些可以进行按位运算的枚举值) 除外。
通俗的讲，自我指涉是指在变量末尾增加了自己类型的一个后缀。

命名	说明
NSString	规范的写法
NSStringObject	自我指涉（不规范）
掩码常量、通知除外：

命名	说明
NSUnderlineByWordMask	规范的写法
NSTableViewColumnDidMoveNotification	规范的写法
【必须】驼峰命名方式。参数名、成员变量、局部变量、属性名都要采用小写字母开头的驼峰命名方式。如果方法名以一个众所周知的大写缩略词开始，可以不适用驼峰命名方式。比如FTP、WWW等。

【建议】一致性。属性/函数/参数/变量/常量/宏 的命名应该具有上下文或者全局的一致性，相同类型或者具有相同作用的变量的命名方式应该相同或者类似。
说明：具体来讲，不同文件中或者不同类中具有相同功能或相似功能的属性的命名应该是相同的或者相似的。好处在于：方便后来的开发者减少代码的阅读量和提高对代码的理解速度。比如：

// count同时定义在NSDictionary、NSArray、NSSet这三个集合类中。且这三个集合类中的count属性都代表同一个意思，即集合中对象的个数。
@property (readonly) NSUInteger count;
【必须】清晰性。属性/函数/参数/变量/常量/宏 的命名应该保持清晰+简洁，如果鱼和熊掌不能兼得，那么清晰更重要。

命名	说明
insertObject:atIndex:	规范的写法
insert:at:	不清晰，插入什么？at代表什么？
removeObjectAtIndex:	规范的写法
removeObject:	规范的写法，因为参数指明了要移除一个对象
remove:	不清晰，移除什么？
【建议】一般情况下，不要缩写或省略单词，建议拼写出来，即使它有点长。当然，在保证可读性的同时，for循环中遍历出来的对象或者某些方法的参数可以缩写。

命名	说明
destinationSelection	规范写法
destSel	不清晰
setBackgroundColor:	规范写法
setBkgdColor:	不清晰
(1.2) 缩写规范
通常，我们都不应该缩写命名(参考General Principles)。然而，下面所列举的都是一些众所周知的缩写，我们可以继续使用这些古老的缩写。在其他情况下，我们需要遵循下面两条缩写建议：

允许使用那些在C语言时代就已经在使用的缩写，比如alloc和getc。
我们可以在命名参数的时候使用缩写。其他情况，尽量不要使用缩写。
我们也可以使用计算机行业通用的缩写。包括但不限于HTML、URL、RTF、HTTP、TIFF、JPG、PNG、GIF、LZW、ROM、RGB、CMYK、MIDI、FTP。

(1.3) Method命名规范
【必须】方法名也要采用小写字母开头的驼峰命名方式。如果方法名以一个中所周知的大写缩略词开头（比如HTTP），该规则可以忽略。

【建议】一般情况下，不要在方法名称中使用前缀，因为他存在于特定类的命名空间中。

【建议】类、协议、函数、常量、枚举等全局可见内容需要添加三个字符作为前缀。苹果保留对任意两个字符作为前缀的使用权。所以尽量不要使用两个字符作为前缀。禁止使用的前缀包括但不限于：NS,UI,CG,CF,CA,WK,MK,CI,NC。

【必须】禁止在方法前面加下划线“ _ ”。Apple官网团队经常在方法前面加下划线"_"。为了避免方法覆盖，导致不可预知的意外，禁止在方法前面加下划线。

【必须】自我描述性。方法的命名也应该具有自我描述性。杜绝中文拼音、过度缩写、或者无意义的命名方式。

【建议】一致性。方法的命名也应该具有上下文或者全局的一致性，相同类型或者具有相同作用的方法的命名方式应该相同或者类似。

// 该方法同时定义在NSView、NSControl、NSCell这三个类里面。
- (NSInteger)tag;
// 该属性同时定义在NSDcitionary和NSArray中。
@property (readonly) NSUInteger count;

【必须】苹果爸爸说：如果一个方法代表某个名词执行的动作，则该方法应该以一个动词开头。如下：

- (void)invokeWithTarget:(id)target;
- (void)selectTabViewItem:(NSTabViewItem *)tabViewItem
【必须】苹果爸爸还说：如果方法代表对象接收的动作，那么方法一动词开头。但不要使用“do”或者"does"作为方法名称的一部分，因为这些助动词不能为方法名称增加太多的意义，反而让方法看起来更加臃肿。同时，也请不要在动词前面使用副词或者形容词。

【必须】如果方法返回接收者的某个属性，那么请直接以属性名作为方法名。如果方法间接的返回一个或多个值，我们可以使用“getxxx”的方式来命名方法。相反，无需额外的在方法名前面添加"get"。

命名	说明
- (NSSize)cellSize;	OK
- (NSSize)calcCellSize;	不OK
- (NSSize)getCellSize;	不OK
【必须】只有当方法间接的返回对象或数值，才有必要在方法名称中使用“get”，这种格式只适用于返回多个数据项的情况。如下：

// 通过传入指针，来获得多个值
- (void)getLineDash:(float *)pattern count:(int*)count phase:(float *)phase;
// NSURLCache (NSURLSessionTaskAdditions)中声明的方法
- (void)getCachedResponseForDataTask:(NSURLSessionDataTask *)dataTask completionHandler:(void (^) (NSCachedURLResponse * __nullable cachedResponse))completionHandler;

【必须】所有参数前面都应该添加关键字，除非你能保证每个人都能意会到你的精神。

命名	说明
- (void)sendAction:(SEL)aSelector toObject:(id)anObject forAllCells:(BOOL)flag;	OK
- (void)sendAction:(SEL)aSelector :(id)anObject :(BOOL)flag;	不OK
【建议】苹果爸爸说：参数之前的单词尽量能描述参数的意义。

命名	说明
- (id)viewWithTag:(NSInteger)aTag;	OK
- (id)taggedView:(int)aTag;	不OK
【必须】如果当前子类创建的方法比从父类继承来的方法更加具体明确。本身提供的方法更具有针对性。则不该重写类本身提供的方法。而是应该单独的提供一个方法，并在新的方法后面添加上必要的关键参数。

命名	说明
- (id)initWithFrame:(CGRect)frameRect;	NSView, UIView.
- (id)initWithFrame:(NSRect)frameRect mode:(int)aMode cellClass:(Class)factoryId numberOfRows:(int)rowsHigh numberOfColumns:(int)colsWide;	NSMatrix, a subclass of NSView
// UIView提供的方法
- (instancetype)initWithFrame:(CGRect)frame
// 更具针对性的方法
- (instancetype)initWithFrame:(CGRect)frame mode:(int)aMode cellClass:(Class)factory Id numberOfRows:(int)rows numberOfColumns:(int)cols;

【建议】请不要使用“and”连接接收者属性。尽管and在下面的例子中读起来还算顺口，但随着你创建的方法参数的增加，这将会带来一系列的问题。

命名	说明
- (int)runModalForDirectory:(NSString *)path file:(NSString *) name types:(NSArray *)fileTypes;	OK
- (int)runModalForDirectory:(NSString *)path andFile:(NSString *)name andTypes:(NSArray *)fileTypes;	不OK
【建议】如果方法描述了两个独立的动作，可以使用“and”连接起来。

命名	说明
- (BOOL)openFile:(NSString *)fullPath withApplication:(NSString *)appName andDeactivate:(BOOL)flag;	OK （NSWorkspace. ）
(1.4) Accessor命名规范
Accessor Methods是指set、get方法。这些方法有一些推荐写法格式：

【建议】如果属性是名词，推荐格式如下：

- (type)noun;
- (void)setNoun:(type)aNoun;
例如：
- (NSString *)title;
- (void)setTitle:(NSString *)aTitle;

【建议】如果属性表示一个形容词，推荐格式如下：

- (BOOL)isAdjective;
- (void)setAdjective:(BOOL)flag;

例如：
- (BOOL)isEditable;
- (void)setEditable:(BOOL)flag;

【建议】如果属性是一个动词，动词使用一般现在时。推荐格式如下：

- (BOOL)verbObject;
- (void)setVerbObject:(BOOL)flag;

例如：
- (BOOL)showsAlpha;
- (void)setShowsAlpha:(BOOL)flag;
【必须】不要把动词的过去分词形式当做形容词来使用。

命名	说明
- (void)setAcceptsGlyphInfo:(BOOL)flag;	OK
- (BOOL)acceptsGlyphInfo;	OK
- (void)setGlyphInfoAccepted:(BOOL)flag;	不OK
- (BOOL)glyphInfoAccepted;	不OK
命名	说明
- (void)setCanHide:(BOOL)flag;	OK
- (BOOL)canHide;	OK
- (void)setShouldCloseDocument:(BOOL)flag;	OK
- (BOOL)shouldCloseDocument;	OK
- (void)setDoesAcceptGlyphInfo:(BOOL)flag;	不OK
- (BOOL)doesAcceptGlyphInfo;	不OK
【建议】可以使用情态动词（can、should、will等）明确方法意义，但不要使用do、does这类无意义的情态动词。

命名	说明
- (void)setCanHide:(BOOL)flag;	OK
- (BOOL)canHide;	OK
- (void)setShouldCloseDocument:(BOOL)flag;	OK
- (BOOL)shouldCloseDocument;	OK
- (void)setDoesAcceptGlyphInfo:(BOOL)flag;	不OK
- (BOOL)doesAcceptGlyphInfo;	不OK
【建议】只有方法间接的返回一个数值，或者需要多个数值需要被返回的时候，才有必要在方法名称中使用“get”。
像这种接收多个参数的方法应该能够传入nil，因为调用者未必对每个参数都感兴趣

 - (void)getLineDash:(float *)pattern count:(int *)count phase:(float *)phase;
(1.5) Parameter命名规范
【必须】不要使用 ”pointer” 或 ”ptr” 命名参数，应该使用参数类型而非它的名字来代表他是否是一个指针。Method Arguments

(1.6) Delegate方法命名规范
delegate methods 又叫做delegation methods，如果delegate对象实现了另一个对象的delegate方法，那么这个对象就可以在它自己某个指定的事件发生时调用delegate对象的delegate方法。delegate方法的命名有一些与众不同的格式：
【建议】以触发消息的对象名开头，省略类名前缀并且首字母小写：

- (BOOL)tableView:(NSTableView *)tableView shouldSelectRow:(int)row;
- (BOOL)application:(NSApplication *)sender openFile:(NSString *)filename;
【建议】除非delegate方法只有一个参数，即触发delegate方法调用的delegating对象，否则冒号是紧跟在类名后面的。

- (BOOL)applicationOpenUntitledFile:(NSApplication *)sender;
【建议】发送通知后再触发delegate方法是一个例外：当delegate方法的调用是为了告诉delegate对象，某个通知已经被发送时，这个delegate方法的参数应该是通知对象，而非触发delegate方法的对象。

- (void)windowDidChangeScreen:(NSNotification *)notification;
【建议】使用did或will这两个情态动词通知delegate对象某件事已经发生或将要发生。

- (void)browserDidScroll:(NSBrowser *)sender;
- (NSUndoManager *)windowWillReturnUndoManager:(NSWindow *)window;
【建议】虽然我们可以在delegate方法中使用did和will来询问delegate是否可以代替另一个对象做某件事情，但是使用should看起来更加完美。

- (BOOL)windowShouldClose:(id)sender;
(1.7) Private方法命名规范
大部分情况下，私有方法的命名和公有方法的命名规则是一样的。然而，通常情况下应该给私有方法添加一个前缀，目的是和公有方法区分开。尽管这样，这种给私有方法加前缀的命名方式有可能引起一些奇怪的问题。问题就是：当你从Cocoa framework（即Cocoa系统库）中的某个类派生出来一个子类时，你并不知道你的子类中定义的私有方法是否覆盖了父类的私有方法，即有可能你自己在子类中实现的私有方法和父类中的某个私有方法同名。在运行时，这极有可能导致一些莫名其妙的问题，并且调试追踪问题的难度也是相当大。
Cocoa frameworks（Cocoa系统库）中的私有方法通常以一个下划线“ _ ”开头，用于标记这些方法是私有的(比如， _fooData ) 。不要问我为什么他们这么做，这大概就是Apple工程师的开发习惯。基于这个事实，提供以下两条建议：
【必须】禁止使用下划线“ _ “作为私有方法的开头。Apple已经预留这种私有方法的命名习惯。

【建议】如果你是要子类化Cocoa Frameworks中的一个非常庞大复杂的类（比如NSView或UIView），并且你想绝对的确保你自己的子类中的私有方法名和父类中的私有方法名不重复。你可以添加一个你自己的前缀作为私有方法的前缀，这个前缀应该尽可能的独特。也许这个前缀是基于你公司或者项目的缩写，比如”XX_“。
尽管给私有方法增加前缀看起来和”方法存在于他们的类的命名空间中“这一之前的说法有些冲突，但此处的意图是：为子类私有方法添加前缀仅仅是为了保证子类方法和父类方法名称不冲突。

【必须】不要在参数的名称中使用“pointer”或者"ptr"。应该使用参数的类型来说明参数是否是一个指针。

【必须】不要使用一到两个字符作为参数名。

【必须】不要对参数的每个单词都缩写。

【建议】如果调用某个方法是为了通知delegate某个事件"即将"发生或者"已经"发生，则请在方法名称中使用“will”或者“did”这样的助动词。例如：

- (void)applicationWillResignActive:(UIApplication *)application;
- (void)applicationDidEnterBackground:(UIApplication *)application;

【建议】如果调用某个方法是为了要求delegate代表其他对象执行某件事情，我们应该在方法中使用“should”这样的情态动词。当然，也可以在方法中使用“did”或者“will”这样的字眼，但更倾向于前者。

- (BOOL)tableViewSholdScroll:(id)sender;
(1.8) Category命名规范
【必须】category中不要声明属性和成员变量。

【必须】避免category中的方法覆盖系统方法。可以使用前缀来区分系统方法和category方法。但前缀不要仅仅使用下划线”_“。

【建议】如果一个类比较复杂，建议使用category的方式组织代码。具体可以参考UIView。

1.9 Class命名规范
【必须】class的名称应该由两部分组成，前缀+名称。即，class的名称应该包含一个前缀和一个名词。

(1.10) Protocol命名规范
命名	说明
NSLocking	OK
NSLock	不好，看起来像是一个类名
【建议】有时候protocol只是声明了一堆相关方法，并不关联class。这种不关联class的protocol使用ing形式以和class区分开来。比如NSLocking而非NSLock。

命名	说明
NSLocking	OK
NSLock	不好，看起来像是一个类名
命名	说明
UITableViewDelegate	OK
NSObjectProtocol	OK
【建议】如果proctocol不仅声明了一堆相关方法，还关联了某个class。这种关联class的protocol的命名取决于关联的class，然后再后面再加上protocol或delegate用于显示的声明这是一份协议。

命名	说明
UITableViewDelegate	OK
NSObjectProtocol	OK
(1.11) Notification命名规范
【建议】苹果爸爸说：如果一个类声明了delegate属性，通常情况下，这个类的delegate对象可以通过实现的delegate方法收到大部分通知消息。那么，这些通知的名称应该反映出对应的delegate方法。比如，application对象发送的NSApplicationDidBecomeActiveNotification通知和对应的applicationDidBecomeActive:消息。其实，这也算是命名的一致性要求。

【必须】notification的命名使用全局的NSString字符串进行标识。命名方式如下：
[Name of associated class] + [Did | Will] + [UniquePartOfName] + Notification
例如：

NSApplicationDidBecomeActiveNotification

NSWindowDidMiniaturizeNotification

NSTextViewDidChangeSelectionNotification

NSColorPanelColorDidChangeNotification
【必须】object通常是指发出notification的对象，如果在发送notification的同时要传递一些额外的信息，请使用userInfo，而不是object。

【必须】如果某个通知是为了告知外界某个事件"即将"发生或者"已经"发生，则请在通知名称中使用“will”或者“did”这样的助动词。例如：

UIKeyboardWillChangeFrameNotification;
UIKeyboardDidChangeFrameNotification;

(1.12) Constant命名规范
Constants

(1.12.1) 枚举常量
【必须】使用枚举类型来表示一组相关的整型常量。

【建议】枚举常量和typedef定义的枚举类型的命名规范同函数的命名规范一致。（参考 Naming Functions）

typedef enum _NSMatrixMode {
    NSRadioModeMatrix           = 0,
    NSHighlightModeMatrix       = 1,
    NSListModeMatrix            = 2,
    NSTrackModeMatrix           = 3
} NSMatrixMode;
注意：上面枚举typeof中的_NSMatrixMode是无用的。
我们可以像位掩码(bit masks)一样创建一个匿名枚举，如下：

enum {
    NSBorderlessWindowMask      = 0,
    NSTitledWindowMask          = 1 << 0,
    NSClosableWindowMask        = 1 << 1,
    NSMiniaturizableWindowMask  = 1 << 2,
    NSResizableWindowMask       = 1 << 3
};
(1.12.2) 使用const关键字创建常量
【必须】使用const关键字创建浮点型常量。你也可以使用const来创建和其他常量不相关的整型常量。否则，请使用枚举类型来创建。即，如果一个整型常量和其他常量不相关，可以使用const来创建，否则，使用枚举类型表示一组相关的整型常量。
以下例子声明了const常量的格式：

const float NSLightGray;
1.12.3 其他常量类型
【必须】通常情况下，不要使用#define预处理命令(preprocessor command)创建常量。正如上面所说，对于整型常量，使用枚举创建；对于浮点型常量，使用const修饰符创建。

【必须】有些符号需要使用大写字母标识。预处理器需要根据这个符号进行计算以便决定是否要对某一块代码进行处理。比如：

#ifdef DEBUG
注意：那些编译器定义的宏，左侧和右侧各有两个下划线。如下：

__MACH__
【必须】通知的名字和字典的key，应该使用字符串常量来定义。使用字符串常量编译器可以进行检查，这样可以避免拼写错误。Cocoa 系统库提供了许多字符串常量的例子，比如：

APPKIT_EXTERN NSString *NSPrintCopies;
字符串常量应该在.h头文件中暴露给外部，而字符串常量真正的赋值是在.m文件中。如下：

.h文件
extern NSString *const WSNetworkReachablityStatusDidChangedNotification;
.m文件
NSString * const WSNetworkReachablityStatusDidChangedNotification = @"WSNetworkReachablityStatusDidChangedNotification";
(1.13) Exception命名规范
Notifications and Exceptions
上面已经有一节介绍过通知的命名规范。异常和通知的命名遵循相似的规则，但又各有不同。

【必须】和Notification的命名规范一样(可参考Notification命名规范一节)，异常也是用全局的NSString字符串进行标识。命名方式如下：
[Prefix] + [UniquePartOfName] + Exception
相当于异常由前缀、名称中能够标识异常唯一性的那部分、Exception。如下：

NSColorListIOException

NSColorListNotEditableException

NSDraggingException

NSFontUnavailableException

NSIllegalSelectorException
(二)编码规范
(2.1) Initialize规范
Tips and Techniques for Framework Developers

(void)initialize类方法先于其他的方法调用。且initialize方法给我们提供了一个让代码once、lazy执行的地方。initialize通常被用于设置class的版本号(参考 Versioning and Compatibility)。
initialize方法的调用遵循继承规则(所谓继承规则，简单来讲是指：子类方法中可以调用到父类的同名方法，即使没有调用[super xxx])。如果我们没有实现initialize方法，运行时初次调用这个类的时候，系统会沿着继承链(类继承体系)，先后给继承链上游中的每个超类发送一条initialize消息，直到某个超类实现了initlialize方法，才会停止向上调用。因此，在运行时，某个类的initialize方法可能会被调用多次(比如，如果一个子类没有实现initialize方法)。
比如：有三个类：SuperClass、SubClass和FinalClass。他们的继承关系是这样的FinalClass->SubClass->SuperClass，现只实现了SuperClass方法的initialize方法。
// SuperClass
@implementation SuperClass
+ (void)initialize {
    NSLog(@"superClass initalize");
}
@end
// 初始化FinalClass
- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event {
    FinalClass *finalC = [FinalClass new];
}
// 控制台输出结果
2018-01-27 22:11:03.130365+0800 Demo[67162:11721965] superClass initalize
2018-01-27 22:11:03.130722+0800 Demo[67162:11721965] superClass initalize
2018-01-27 22:11:03.130815+0800 Demo[67162:11721965] superClass initalize
解释：
因为FinalClass继承自SubClass，SubClass继承自SuperClass。因为继承体系中只有SuperClass实现了initialize方法，导致初始化FinalClass这个子类时，FinalClass会调用他的父类(SubClass)中的initialize方法。又因为他(FinalClass)的父类(SubClass)也没有实现initialize方法，又会继续沿着继承体系，向上游寻找，最后找到SubClass的父类(SuperClass)。因为SuperClass实现了这个initialize方法，所以调用结束。至于为什么是连续调用了三次SuperClass的initialize方法。因为子类FinalClass的初始化触发了超类SubClass、SuperClass的初始化。所以初始化FinalClass时，实际上使这三个类都得到了初始化的机会，自然就会连续调用三次SuperClass的initialize方法。
还是上面那三个类，如果我们又给SubClass实现了initialize方法，那么控制台将会输出如下结果(至于为什么，前面已经介绍过了，大家可以自己分析下)：

2018-01-27 22:34:54.697952+0800 Load[67652:11780578] superClass initalize
2018-01-27 22:34:54.698118+0800 Load[67652:11780578] subClass initialize
2018-01-27 22:34:54.698472+0800 Load[67652:11780578] subClass initialize
基于上面陈述的这些事实，我们得出一个结论：
【必须】如果我们想要让initialize方法仅仅被调用一次，那么需要借助于GCD的dispatch_once()。如下：

+ (void)initialize {
    static dispatch_once_t onceToken = 0;
    dispatch_once(&onceToken, ^{
        // the initializing code
    }
}
【建议】如果我们想在继承体系的某个指定的类的initialize方法中执行一些初始化代码，可以使用类型检查和而非dispatch_once()。如下：

if (self == [NSFoo class]) {
    // the initializing code
}
说了这么多，总而言之，由于任何子类都会调用父类的initialize方法，所以可能会导致某个父类的initialize方法会被调用多次，为了避免这种情况，我们可以使用类型判等或dispatch_once()这两种方式，以保证initialize中的代码不会被无辜调用。

initialize是由系统自动调用的方法，我们不应该显示或手动调用initialize方法。如果我们要触发某个类的初始化行为，应该调用这个类的一些无害的方法。比如：

[NSImage self];
(2.2 )Init方法规范
Objective-C有designated Initializers和secondary Initializers的概念。designated Initializers叫做指定初始化方法。《Effective Objective-C 2.0 编写高质量iOS 与 OS X代码的52个有效方法》中将designated Initializers翻译为”全能初始化方法“。designated Initializers方法是指类中为对象提供必要信息以便其能完成工作的初始化方法。一个类可以有一个或者多个designated Initializers。但是要保证所有的其他secondary initializers都要调用designated Initializers。即：只有designated Initializers才会存储对象的信息。这样的好处是：当这个类底层的某些数据存储机制发生变化时(可能是一些property的变更)，只需要修改这个designated Initializers内部的代码即可。无需改动其他secondary Initializers初始化方法的代码。

【必须】所有secondary 初始化方法都应该调用designated 初始化方法。

【必须】所有子类的designated初始化方法都要调用父类的designated初始化方法。使这种调用关系沿着类的继承体系形成一条链。

【必须】如果子类的designated初始化方法与超类的designated初始化方法不同，则子类应该覆写超类的designated初始化方法。（因为开发者很有可能直接调用超类的某个designated方法来初始化一个子类对象，这样也是合情合理的，但使用超类的方法初始化子类，可能会导致子类在初始化时缺失一些必要信息）。

【必须】如果超类的某个初始化方法不适用于子类，则子类应该覆写这个超类的方法，并在其中抛出异常。

【必须】禁止子类的designated初始化方法调用父类的secondary初始化方法。否则容易陷入方法调用死循环。如下：

// 超类
@interface ParentObject : NSObject

@end

 @implementation ParentObject

    //designated initializer    
    - (instancetype)initWithURL:(NSString*)url title:(NSString*)title {
        if (self = [super init]) {
            _url = [url copy];
            _title = [title copy];
        }
        return self;
    }
    //secondary initializer
    - (instancetype)initWithURL:(NSString*)url {
        return [self initWithURL:url title:nil];
    }

    @end

// 子类
@interface ChildObject : ParentObject

@end

    @implementation ChildObject
    //designated initializer
    - (instancetype)initWithURL:(NSString*)url title:(NSString*)title {
        //在designated intializer中调用 secondary initializer，错误的
        if (self = [super initWithURL:url]) {

        }
        return self;
    }
    @end

 @implementation ViewController
    - (void)viewDidLoad {
        [super viewDidLoad];
        // 这里会死循环
        ChildObject* child = [[ChildObject alloc] initWithURL:@"url" title:@"title"];
    }
    @end
【必须】另外禁止在init方法中使用self.xxx的方式访问属性。如果存在继承的情况下，很有可能导致崩溃。具体参考本人之前的文章《为什么不能在init和dealloc函数中使用accessor方法》

(2.3) Init error
一个好的初始化方法应该具备以下几个方面，在初始化阶段就能够发现错误并给予处理，也就是初始化方法应该具备一些必要的容错功能。

【必须】调用父类的designated初始化方法初始化本类的对象。

【必须】校验父类designated初始化方法返回的对象是否为nil。

【建议】如果初始化当前对象的时候发生了错误，应该给予对应的处理：释放对象，并返回nil。
以下实例列举类初始化阶段可能会存在的错误：

- (id)init {
    self = [super init];  // Call a designated initializer here.
    if (self != nil) {
        // Initialize object  ...
        if (someError) {
            [self release];
            self = nil;
        }
    }

    return self;
}
(2.4) dealloc规范
【必须】不要忘记在dealloc方法中移除通知和KVO。

【建议】dealloc 方法应该放在实现文件的最上面，并且刚好在 @synthesize 和 @dynamic 语句的后面。在任何类中，init 都应该直接放在 dealloc 方法的下面。

【必须】在dealloc方法中，禁止将self作为参数传递出去，如果self被retain住，到下个runloop周期再释放，则会造成多次释放crash。如下：

-(void)dealloc{
    [self unsafeMethod:self];
    // 因为当前已经在self这个指针所指向的对象的销毁阶段，销毁self所指向的对象已经在所难免。如果在unsafeMethod:中把self放到了autorelease poll中，那么self会被retain住，计划下个runloop周期在进行销毁。但是dealloc运行结束后，self所指向的对象的内存空间就直接被回收了，但是self这个指针还没有销毁(即没有被置为nil)，导致self变成了一个名副其实的野指针。
    // 到了下一个runloop周期，因为self所指向的对象已经被销毁，会因为非法访问而造成crash问题。
}
【必须】和init方法一样，禁止在dealloc方法中使用self.xxx的方式访问属性。如果存在继承的情况下，很有可能导致崩溃。具体参考本人之前的文章《为什么不能在init和dealloc函数中使用accessor方法》、、

(2.5) Block规范
【必须】调用block时需要对block判空。

【必须】注意block潜在的引用循环。

(2.6) Notification规范
前面在命名规范一章中已经介绍了通知的命名规范，这里解释的是通知的使用规范。
通知作为观察者模式的一个落地产物，在开发中能够实现一对多的通信。所有可以使用delegate和block实现的通信和传值，都可以使用通知实现。正因通知如此灵活，我们更应该弄清楚通知适合使用的场景，避免把通知和delegate以及block等进行混淆。
通知是一把双刃剑，让你欢喜让你忧。开发中，当你走投无路将要崩溃时，可以考虑使用通知；而当你频繁使用通知时，同样会让你崩溃到走投无路。所以，在每个应用中，我们应该时刻留意并控制通知的数量，避免通知满天飞的现象。
曾经有一个项目摆在我面前，我却无法珍惜，因为通知太多了，几乎有代码的地方就有通知。如果现在同样有一个充满通知的项目摆在我面前，我知道是时候该优化它了。

【必须】基于以上的陈述，当我们使用通知时，必须要思考，有没有更好的办法来代替这个通知。禁止遇到问题就想到通知，把通知作为备选项而非首选项。

【必须】post通知时，object通常是指发出notification的对象，如果在发送notification的同时要传递一些额外的信息，请使用userInfo，而不是object。

【必须】NSNotificationCenter在iOS8及更老的系统有一个多线程bug，selector执行到一半可能会因为self的销毁而引起crash，解决的方案是在selector中使用weak_strong_dance。如下：

- (void)onMultiThreadNotificationTrigged:(NSNotification *)notify {
    __weak typeof(self) wself = self; __strong typeof(self) sself = wself; 
    if (!sself) { return; }
    [self doSomething]; 
}
【必须】在多线程应用中，Notification在哪个线程中post，就在哪个线程中被转发，而不一定是在注册观察者的那个线程中。如果post消息不在主线程，而接受消息的回调里做了UI操作，需要让其在主线程执行。
说明：每个进程都会创建一个NotificationCenter，这个center通过NSNotificationCenter defaultCenter获取，当然也可以自己创建一个center。
NoticiationCenter是以同步（非异步，当前线程，会等待，会阻塞）的方式发送请求。即，当post通知时，center会一直等待所有的observer都收到并且处理了通知才会返回到poster。如果需要异步发送通知，请使用notificationQueue，在一个多线程的应用中，通知会发送到所有的线程中。

(2.7) UI规范
【必须】如果想要获取window，不要使用view.window获取。请使用[[UIApplication sharedApplication] keyWindow]。

【必须】在使用到 UIScrollView，UITableView，UICollectionView 的 Class 中，需要在 dealloc 方法里手动的把对应的 delegate, dataSouce 置为 nil。

【必须】UITableView使用self-sizing实现不等高cell时，请在- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath;中给cell设置数据。不要在- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath;方法中给cell设置数据。

【建议】当访问一个 CGRect 的 x， y， width， height 时，应该使用CGGeometry 函数代替直接访问结构体成员。苹果的 CGGeometry 参考中说到：

All functions described in this reference that take CGRect data structures as inputs implicitly standardize those rectangles before calculating their results. For this reason, your applications should avoid directly reading and writing the data stored in the CGRect data structure. Instead, use the functions described here to manipulate rectangles and to retrieve their characteristics.

因此，推荐的写法是这样的：

CGRect frame = self.view.frame;

CGFloat x = CGRectGetMinX(frame);
CGFloat y = CGRectGetMinY(frame);
CGFloat width = CGRectGetWidth(frame);
CGFloat height = CGRectGetHeight(frame);
反对这样的写法：

CGRect frame = self.view.frame;

CGFloat x = frame.origin.x;
CGFloat y = frame.origin.y;
CGFloat width = frame.size.width;
CGFloat height = frame.size.height;
(2.8) IO规范
【建议】尽量少用NSUserDefaults。
说明：[[NSUserDefaults standardUserDefaults] synchronize] 会block住当前线程，知道所有的内容都写进磁盘，如果内容过多，重复调用的话会严重影响性能。

【建议】一些经常被使用的文件建议做好缓存。避免重复的IO操作。建议只有在合适的时候再进行持久化操作。

2.9 Collection规范
【必须】不要用一个可能为nil的对象初始化集合对象，否则可能会导致crash。

// 可能崩溃
NSObject *obj = somOjbcetMaybeNil;
NSMutableArray *arrM = [NSMutableArray arrayWithObject:obj];

// 崩溃信息：
*** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '*** -[__NSPlaceholderArray initWithObjects:count:]: attempt to insert nil object from objects[0]’

// 改进办法:
NSObject *obj = somOjbcetMaybeNil;
NSMutableArray *arrM = nil;
if (obj && [obj isKindOfClass:[NSObject class]]) {
    arrM = [NSMutableArray arrayWithObject:obj];
} else {
    arrM = nil;
}
【必须】同理，对插入到集合对象里面的对象也要进行判空。

【必须】注意在多线程环境下访问可变集合对象的问题，必要时应该加锁保护。不可变集合(比如NSArray)类默认是线程安全的，而可变集合类(比如NSMutableArray)不是线程安全的。

【必须】禁止在多线程环境下直接访问可变集合对象中的元素。应该先对其进行copy，然后访问不可变集合对象内的元素。

// 正确写法
- (void)checkAllValidItems{
NSArray *array = [array copy];
[array enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
//do something using obj
}]; }

// 错误写法
- (void)checkAllValidItems{
[self.allItems enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
    //do something using obj
    // 如果在enumerate过程中，其他线程对allItems这个可变集合进行了变更操作，这里就有可能引发crash
}]; }
【必须】注意使用enumerateObjectsUsingBlock遍历集合对象中的对象时，关键字return的作用域。block中的return代表的是使当前的block返回，而非使当前的整个函数体返回。以下使用NSArray举例，其他集合类型同理。如下：

- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event {
    NSArray *array = [NSArray arrayWithObject:@"1"];
    [array enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        // excute some code...
        return;
    }];
    // 依然会执行到这里
    NSLog(@"fall through");
}

// 执行结果：
// fall through
当然，两个enumerateObjectsUsingBlock嵌套，如果仅在最内层的block中return，外层block的代码还是会被执行。如下：

- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event {
    NSArray *arr1 = [NSArray arrayWithObject:@"1"];
    NSArray *arr2 = [NSArray arrayWithObject:@"2"];
    [arr2 enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        [arr1 enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
            // do something
            return;
        }];
        
        NSLog(@"fall through");
    }];
    
    NSLog(@"fall through");
}

// 执行结果：
// fall through
// fall through

说明：其实block相当于一个匿名函数，在block中使用return返回，仅是让当前这个匿名函数返回。

【必须】禁止返回mutable对象，禁止mutable对象作为入参传递。

【建议】如果使用NSMutableDictionary作为缓存，建议使用NSCache代替。

【建议】集合类使用泛型来指定对象的类型。

@property(nonatomic,copy) NSArray<NSString *> *array;
@property(nonatomic,strong) NSMutableDictionary<NSString *,NSString *> *dictionary;
(2.10) 分支语句规范
【建议】if条件判断语句后面必须要加大括号{}。不然随着业务的发展和代码迭代，极有可能引起逻辑问题。

// 建议
if (!error) {
    return success;
}
// 不建议
if (!error) 
    return success;

if (!error)  return success;

【必须】多于3个逻辑表达式必须用参数分割成多个有意义的bool变量。

【建议】遵循gold path法则，不要把真正的逻辑写道括号内。

// 不建议
- (void)someFuncWith:(NSString *)parameter {
    if (parameter) {
        // do something
        [self doSomething];
    }
}

// 建议
- (void)someFuncWith:(NSString *)parameter {
    if (!parameter) {
        return;
    }
    // do something
    [self doSomething];
}

【建议】对于条件语句的真假，因为 nil 解析为 NO，所以没有必要在条件中与它进行比较。永远不要直接和 YES 和 NO进行比较，因为 YES 被定义为 1，而 BOOL 可以多达 8 位。

// 建议
if (isAwesome)
if (![someObject boolValue])
// 禁止这样做
if ([someObject boolValue] == NO) { }
if (isAwesome == YES) { } 
【必须】使用switch...case...语句的时候，不要丢掉default:。除非switch枚举。

【必须】switch...case...语句的每个case都要添加break关键字，避免出现fall-through。

(2.11) 对象判等规范
isEqual:方法允许我们传入任意类型的对象作为参数，如果参数类型和receiver(方法调用者)类型不一致，会返回NO。而isEqualToString:和isEqualToArray:这两个方法会假设参数类型和receiver类型一致，也就是说，这两个方法不会对参数进行类型检查。因此这两个方法性能更好但不安全。如果我们是从外部数据源(比如info.plist或preferences)获取的数据，那么推荐使用isEqual:，因为这样更安全。如果我们知道参数的确切类型，那么可以使用类似于isEqualToString:这样的方法，因为性能更好。关于对象等同性判定的更多内容，请参考笔者之前的文章《浅析对象等同性判断》。

(2.12) 懒加载规范
懒加载适合的场景：

一个对象的创建依赖于其他对象。
一个对象在整个app过程中，可能被使用，也可能不被使用。
一个对象的创建需要经过大量的计算或者比较消耗性能。除以上三条之外，请不要使用懒加载。
【建议】懒加载本质上就是延迟初始化某个对象，所以，懒加载仅仅是初始化一个对象，然后对这个对象的属性赋值。懒加载中不应该有其他的不必要的逻辑性的代码，如果有，请把那些逻辑性代码放到合适的地方。

【必须】不要滥用懒加载，只对那些真正需要懒加载的对象采用懒加载。

【必须】如果一个对象在懒加载后，某些场景下又被设置为nil。我们很难保证这个懒加载不被再次触发。

(2.13) 多线程规范
【必须】禁止使用GCD的dispatch_get_current_queue()函数获取当前线程信息。
【必须】对剪贴板的读取必须要放在异步线程处理，最新Mac和iOS里的剪贴板共享功能会导致有可能需要读取大量的内容，导致读取线程被长时间阻塞。

【建议】仅当必须保证顺序执行时才使用dispatch_sync，否则容易出现死锁，应避免使用，可使用dispatch_async。

 - (void)viewDidLoad {
   [super viewDidLoad];
   // 错误。出现死锁，报错:EXC_BAD_INSTRUCTION。原因:在主队列中同步的添加一个block到主队列中
   dispatch_queue_t mainQueue = dispatch_get_main_queue();
   dispatch_block_t block = ^() {
       NSLog(@"%@", [NSThread currentThread]);
   };
   dispatch_sync(mainQueue, block);
}

 - (void)viewDidLoad {
   [super viewDidLoad];
   // 正确。异步执行。虽然还是把任务加到了主队列由主线程来执行，但因为是异步，此时主队列后面的任务不依赖于前面的任务。
   dispatch_queue_t mainQueue = dispatch_get_main_queue();
   dispatch_block_t block = ^() {
       NSLog(@"%@", [NSThread currentThread]);
   };
   dispatch_async(mainQueue, block);
}
// 打印结果：
// <NSThread: 0x600000073300>{number = 1, name = main}

【必须】禁止在非主线程中进行UI元素的操作。

【必须】在主线程中禁止进行同步网络资源读取，使用NSURLSession进行异步获取。当然，你可以在子线程同步获取网络资源，但还是上面的那一条建议：避免使用dispatch_sync，尽量使用dispatch_async。因为死锁不一定只发生在主线程。

【必须】如果需要进行大文件或者多文件的IO操作，禁止主线程使用，必须进行异步处理。

【必须】对剪贴板的读取必须要放在异步线程处理，最新Mac和iOS里的剪贴板共享功能会导致有可能需要读取大量的内容，导致读取线程被长时间阻塞。

dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
   UIPasteboard *pasteboard = [UIPasteboard generalPasteboard]; 
   if (pasteboard.string.length > 0) {//这个方法会阻塞线程
      NSString *text = [pasteboard.string copy];
      [pasteboard setValue:@"" forPasteboardType:UIPasteboardNameGeneral];
      if (text == nil || [text isEqualToString:@""]) {
          return ;
      }
      dispatch_async(dispatch_get_main_queue(), ^{
          [self processShareCode:text];
      });
   }
});

2.14 内存管理规范
【建议】函数体提前return时，要注意是否有对象没有被释放掉(常见于CF对象)，避免造成内存泄露。

【建议】请慎重使用单例，避免产生不必要的常驻内存。
说明：我们不仅应该知道单例的特点和优势，也必须要弄明白单例适合的场景。UIApplication、access database 、request network 、access userInfo这类全局仅存在一份的对象或者需要多线程访问的对象，可以使用单例。不要仅仅为了访问方便就使用单例。

【建议】单例初始化方法中尽量保证单一职责,尤其不要进行其他单例的调用。极端情况下，两个单例对象在各自的单例初始化方法中调用，会造成死锁。

【必须】在dealloc方法中，禁止将self作为参数传递出去，如果self被retain住，到下个runloop周期再释放，则会造成多次释放crash。这一点在dealloc一节中有说明。

【建议】除非你清除的知道自己在做什么。否则不建议将UIView类的对象加入到NSArray、NSDictionary、NSSet中。如有需要可以添加到NSMapTable 和 NSHashTable。因为NSArray、NSDictionary、NSSet会对加入的对象做strong引用（即使你把加入的对象进行了weak）。而NSMapTable、NSHashTable会对加入的对象做weak引用。
说明：简单的说，NSHashTable相当于weak的NSMutableArray；NSMapTable相当于weak的NSMutableDictionary.

// 错误的例子：
@implementation WSObject
- (void)dealloc {
    NSLog(@"dealloc");
}
@end

- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event {
    WSObject *object = [WSObject new];
    // 即使对object进行了weak弱化，数组也会强引用这个object对象。dealloc方法不会被执行。
    __weak typeof(object) weakObject = object;
    [self.arrM addObject:weakObject];
    
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        NSLog(@"count = %ld",self.arrM.count);
    });
}

// 打印结果：
// count = 1

// 正确的例子：
- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event {
    WSObject *object = [WSObject new];

    NSHashTable *hashTable = [NSHashTable weakObjectsHashTable];
    [hashTable addObject:object];
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        NSLog(@"count = %ld",hashTable.count);
    });
}

// 打印结果：
// dealloc
// count = 1
你可能对上面的例子有所疑惑，object已经释放了，但是控制台仍然输出 hashTable.count == 1。但是请相信我，此时存在于hashTable中的那个object已经变成了nil。不信你继续看下面的例子：

- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event {
    WSObject *object = [WSObject new];

    NSHashTable *hashTable = [NSHashTable weakObjectsHashTable];
    [hashTable addObject:object];
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        NSLog(@"count = %ld",hashTable.count);
        
        if (hashTable && hashTable.count) {
            WSObject *object = [hashTable anyObject];
            NSLog(@"object = %@",[object self]);
        }
    });
}

// 打印结果：
2017-07-04 22:19:10.952139+0800 tst[46834:4305636] dealloc
2017-07-04 22:19:13.149903+0800 tst[46834:4305636] count = 1
2017-07-04 22:20:55.234522+0800 tst[46834:4305636] object = (null)

(2.15) 延迟调用规范
【必须】performSelector:withObject:afterDelay:要在有Runloop的线程里调用，否则调用无法生效。
说明：异步线程默认是没有runloop的，除非手动创建；而主线程是系统会自动创建Runloop的。所以在异步线程调用是请先确保该线程是有Runloop的。

使用performSelector:withObject:afterDelay:和cancelPreviousPerformRequestsWithTarget组合的时候要小心：
afterDelay会增加引用计数，而cancel会对引用计数减一
如果receiver在引用计数器为1的时候，调用cancel会立即回收receiver。后续再次调用receiver的方法就会crash。所以我们需要使用weakSelf并判空。如下：

__weak typeof(self) weakSelf = self;
[NSObject cancelPreviousPerformRequestsWithTarget:self]; 
if (!weakSelf) {
    // NSLog(@"self dealloc");
    return;
 }
[self doOther];
(2.16) 注释规范
【必须】如果方法、函数、类、属性等需要提供给外界或者他人使用，必须要加注释说明。
【必须】如果你的代码以SDK的形式提供给其他人使用，那么接口的注释是必须的。必须对暴露给外界的所有方法、属性、参数加以注释说明。
【建议】注释应该说明其作用以及注意事项(如果有)。
【建议】因为方法或属性本身就具有自我描述性，注释应该简明扼要，说明是什么和为什么即可。

(2.17) 类的设计规范
【建议】尽量减少继承，类的继承关系不要超过3层。可以考虑使用category、protocol来代替继承。

【建议】把一些稳定的、公共的变量或者方法抽取到父类中。子类尽量只维持父类所不具备的特性和功能。

【建议】.h文件中尽量不要声明成员变量。

【建议】.h文件中的属性尽量声明为只读。

【建议】.h文件中只暴露出一些必要的类、公开的方法、只读属性；私有类、私有方法和私有属性以及成员变量，尽量写在.m文件中。

(2.18) 代码组织规范
参考 raywenderlich/objective-c-style-guide

#pragma mark - Lifecycle
- (instancetype)init {}

- (void)dealloc {}

- (void)viewDidLoad {}

- (void)viewWillAppear:(BOOL)animated {}

- (void)didReceiveMemoryWarning {}

#pragma mark - Custom Accessors
- (void)setCustomProperty:(id)value {}

- (id)customProperty {}

#pragma mark - IBActions
- (IBAction)submitData:(id)sender {}

#pragma mark - Public
- (void)publicMethod {}

#pragma mark - Private
- (void)privateMethod {}

#pragma mark - UITextFieldDelegate

#pragma mark - UITableViewDataSource

#pragma mark - UITableViewDelegate

#pragma mark - NSCopying
- (id)copyWithZone:(NSZone *)zone {}

#pragma mark - NSObject
- (NSString *)description {}
【建议】以上只是提供了组织代码的一种思路，如果有其他更好的组织方式，也不是不可以。

(2.19) 工程结构规范
【必须】为了避免文件杂乱，物理文件应该保持和 Xcode 项目文件同步。Xcode 创建的任何组（group）都必须在文件系统有相应的映射。为了更清晰，代码不仅应该按照类型进行分组，也可以根据业务功能进行分组。

【建议】合理组织工程的内的文件夹，工程中一般包括但不限于以下几个文件夹category(分类)、util/helper(工具类)、resource(资源)、const(常量)、third(第三方)。

【建议】尽可能一直打开 target Build Settings 中 "Treat Warnings as Errors" 以及一些额外的警告。如果你需要忽略指定的警告,使用 Clang 的编译特性 。

作者：VV木公子
链接：https://www.jianshu.com/p/c818c00e0690
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
<font size="1">2020-01-02 16:12 PM</font>
<hr>

vim实用技巧 
<font size="1">2020-01-02 11:06 AM</font>
<hr>

共事的第一原则就是说的话要让人听懂,说人话.
<font size="1">2019-12-31 16:02 PM</font>
<hr>

kemper,种草了
<font size="1">2019-12-28 22:56 PM</font>
<hr>

nektar t6 中的推子是有几个模式的,其中一个模式就是只有推子接近软件中的推子的临界范围才可以进行控制,这个从一定程度上解决了没有电动推子的情况下避免大范围的数值改动,太有想法了.
<font size="1">2019-12-28 22:55 PM</font>
<hr>

spindump进程CPU占用率高
<font size="1">2019-12-28 22:10 PM</font>
<hr>

喝一两瓶啤酒后会渴,喝十瓶却不会.
<font size="1">2019-12-28 13:54 PM</font>
<hr>

W3C 􏰽用􏰩了􏲭􏵱􏳾作语义:XQuery 1.0 和 XPath 2.0 􏰔􏶒􏰛http://www.w3.org/TR/xquery- semantics/􏰜􏱓用数学􏴁的􏲢理􏰔􏰖􏳤􏴝􏰓的语言􏰻􏰼􏰠􏲌􏵹􏰋，并􏱭 XQuery 和 XPath 􏰔 􏶒全􏲄的 3.0 版本􏰛http://www.w3.org/TR/xpath-full-text-30/􏰜􏰪􏶓了一􏰂􏱓用 XQuery 􏴊成 的􏲭􏵱语义。
<font size="1">2019-12-27 17:47 PM</font>
<hr>

KM 把print_screen识别为F13,所以要自定义这个键还是用karabiner吧
<font size="1">2019-12-27 12:27 PM</font>
<hr>

Dash里有个选项可以隐藏自己在dock里的icon,真是用心
<font size="1">2019-12-26 15:35 PM</font>
<hr>

表达式和语句,表达式不会对环境有影响,而语句则不是
<font size="1">2019-12-21 22:24 PM</font>
<hr>

logic pro 里的轨道中可以操作apogee 48V幻象供电,这个设计非常好.
<font size="1">2019-12-21 11:07 AM</font>
<hr>

搞懂了self是什么,就搞懂了ruby的元编程
<font size="1">2019-12-20 17:15 PM</font>
<hr>

Abstract Semantics Tree
<font size="1">2019-12-20 13:10 PM</font>
<hr>

又一个线上学院 https://www.udemy.com/
<font size="1">2019-12-19 11:11 AM</font>
<hr>

版本的保护期50年,音乐家在世50年,死后50年,后面就可以自由使用了.
<font size="1">2019-12-19 10:27 AM</font>
<hr>

排他&非排他,就是独家啦
<font size="1">2019-12-19 10:21 AM</font>
<hr>

音乐授权与转授权,就是房东出租和二房东:)
<font size="1">2019-12-19 10:20 AM</font>
<hr>

编曲,特别是电脑制作,应该叫做music producer
<font size="1">2019-12-19 10:18 AM</font>
<hr>

they don't they don't speak for us!!
<font size="1">2019-12-18 11:09 AM</font>
<hr>

go,25关键字
<font size="1">2019-12-18 08:54 AM</font>
<hr>

python,31个关键字
<font size="1">2019-12-18 08:54 AM</font>
<hr>

java,53个关键字
<font size="1">2019-12-17 22:16 PM</font>
<hr>

dart ,60个关键字
<font size="1">2019-12-17 22:16 PM</font>
<hr>

[https://learngitbranching.js.org/](https://learngitbranching.js.org/)
<font size="1">2019-12-17 17:47 PM</font>
<hr>

为什么研究底层的原理,重要的不是为了知道更多,而是更好的理解上层抽象短板
<font size="1">2019-12-17 15:33 PM</font>
<hr>

记录的要点: 1.与自己理解有偏差的 2.自己不理解的 3.备忘
<font size="1">2019-12-17 09:09 AM</font>
<hr>

第一次使用iphone的设置新手机功能,很新鲜
<font size="1">2019-12-16 17:22 PM</font>
<hr>

[-._a-zA-Z0-9],文件命名
<font size="1">2019-12-16 16:52 PM</font>
<hr>

[Go 开发者路线图](https://github.com/Alikhll/golang-developer-roadmap/blob/master/i18n/zh-CN/ReadMe-zh-CN.md)
<font size="1">2019-12-16 15:02 PM</font>
<hr>

[https://github.com/shockerli/go-awesome](https://github.com/shockerli/go-awesome)
<font size="1">2019-12-16 13:14 PM</font>
<hr>
[Linux/Unix系统编程手册源码(TLPI)](http://man7.org/tlpi)
<font size="1">2019-12-16 10:27 AM</font>

<hr>

腾讯视频app,英文名叫 QQlive,然后我在alfred里就找不到了
<font size="1">2019-12-14 23:44 PM</font>
<hr>

四门语言要学: 1.初学者要学的;2.使用最多的;3.最有挑战的;4面向未来的;
<font size="1">2019-12-14 23:03 PM</font>
<hr>

了解技术,会写文案,懂业务
<font size="1">2019-12-13 21:13 PM</font>
<hr>

陆奇：对我来讲一个很大的挑战是，如果一个人他对你讲的话，和他想的、做的不一致，这样就没法真正共处了。
<font size="1">2019-12-13 10:57 AM</font>
<hr>

《晚点》：在大公司做管理，如何做到穿透管理，真正了解一线的情况？

陆奇：我以前要求自己做到的是，我手下两层以下的人，他们每个人的工作我都能做。这样整个公司里，没有人敢欺骗你、忽悠你。这个非常重要，大部分企业中层都在忽悠高层，资源其实是浪费掉的。
<font size="1">2019-12-13 10:51 AM</font>
<hr>

陆奇：长期，车未必是人类最有效的交通工具，因为你要大规模造路、要基础建设。

如果你去和卡耐基梅隆大学做机器人研究的教授和学生交流，有不少人会跟你讲，在自然界蛇是在能量很低的情况下，在任何的地形都可以走，它靠骨头运动，比有脚的动物要好。这和中国以前想像出来的龙相似。

也许有人在未来可以做一个机器龙一样的东西，将来新一代的运物工具可能既不是车也不是飞机，而是一种新的物。不要把无人驾驶仅仅看成就是要造车，而应该把它看成一种新的能力、一种人类历史上没有过的能力，我们可以建一个自己可以动的体系。
<font size="1">2019-12-13 10:49 AM</font>
<hr>

《晚点》：黄峥曾说，媒体的价值大于拼多多，而拼多多的价值大于人工智能公司。他认为1万个人工智能公司都比不上让五环外的人买到好的手纸重要，你是否理解并认可他的观点？
<font size="1">2019-12-13 10:47 AM</font>
<hr>

创造大规模价值，是集中式机会多还是分布式的机会更多？
<font size="1">2019-12-13 10:46 AM</font>
<hr>

创造大规模价值，是集中式机会多还是分布式的机会更多？
<font size="1">2019-12-13 10:42 AM</font>
<hr>

`brew install youtube-dl`
<font size="1">2019-12-12 14:03 PM</font>
<hr>

提供有价值的信息是第一重要的
<font size="1">2019-12-12 11:21 AM</font>
<hr>

电子货币只是法币的另一种形式
<font size="1">2019-12-11 17:51 PM</font>
<hr>

数字货币,也叫加密货币
<font size="1">2019-12-11 17:50 PM</font>
<hr>

苹果的Music APP真的是各种槽点,界面无当前播放时间,总时间,需要鼠标悬浮才能显示,为了所谓界面简洁,是不是有点过了
<font size="1">2019-12-11 17:42 PM</font>
<hr>

spoil instance
<font size="1">2019-12-11 16:03 PM</font>
<hr>

chaos engeerring
<font size="1">2019-12-11 15:58 PM</font>
<hr>

chaos theory
<font size="1">2019-12-11 15:56 PM</font>
<hr>

Catalina中的Mail.app 中的内容不再允许第三方APP检索了
<font size="1">2019-12-11 15:06 PM</font>
<hr>

	SCPT文件是由Apple开发的AppleScript Script File
<font size="1">2019-12-11 14:57 PM</font>
<hr>

alfred 的trigger使用.开头是个好主意.
<font size="1">2019-12-11 10:20 AM</font>
<hr>

武功尽废,受之有愧
<font size="1">2019-12-10 16:11 PM</font>
<hr>

用ffmpeg分离音视频流
<font size="1">2019-12-10 13:26 PM</font>
<hr>

表达善意是不错的,更重要的是别人能接受多少,无论是方式还是认知上的差异
<font size="1">2019-12-10 13:05 PM</font>
<hr>

每一件让你后悔的小事应该都是值得的,有价值的.大事另说.
<font size="1">2019-12-10 13:03 PM</font>
<hr>

春种一粒粟，秋收万颗子。
四海无闲田，农夫犹饿死。
锄禾日当午，汗滴禾下土。
谁知盘中餐，粒粒皆辛苦。
<font size="1">2019-12-09 20:42 PM</font>
<hr>

go 的chan的广播真是妙啊
<font size="1">2019-12-09 17:59 PM</font>
<hr>

Hello Github [https://github.com/521xueweihan/HelloGitHub](https://github.com/521xueweihan/HelloGitHub)
<font size="1">2019-12-09 09:16 AM</font>
<hr>

CSP vs. Actor
<font size="1">2019-12-08 11:09 AM</font>
<hr>

又一个跨平台的GUI开发框架[https://sciter.com/](https://sciter.com/)
<font size="1">2019-12-08 09:13 AM</font>
<hr>

[:3] 这么设计的原因应该是除了表示规则之外,还能表示获取的数量.
<font size="1">2019-12-07 10:29 AM</font>
<hr>

当我输入 os.Args.len的时候,直接转成了len(os.Args),感动到哭
<font size="1">2019-12-07 08:16 AM</font>
<hr>

不得不说GoLand是所有go ide里做的最好的
<font size="1">2019-12-07 08:06 AM</font>
<hr>

cobra 眼睛蛇
<font size="1">2019-12-06 09:07 AM</font>
<hr>

An example of gin
https://github.com/eddycjy/go-gin-example
<font size="1">2019-12-05 20:01 PM</font>
<hr>

A Commander for modern Go CLI interactions
[go下面的cli框架](https://github.com/spf13/cobra)
<font size="1">2019-12-05 19:39 PM</font>
<hr>

[https://www.pinterest.com/](https://www.pinterest.com/)
<font size="1">2019-12-05 05:08 AM</font>
<hr>

pyramid ,py开头的单词来作为语言框架的命名方式是个不错的主意.
<font size="1">2019-12-05 04:51 AM</font>
<hr>

https://0.30000000000000004.com/
<font size="1">2019-12-04 19:58 PM</font>
<hr>

烦躁不安
<font size="1">2019-12-03 17:45 PM</font>
<hr>

Stackless
<font size="1">2019-12-03 15:22 PM</font>
<hr>

Init() & Invoke()
<font size="1">2019-12-03 09:11 AM</font>
<hr>

_ * 都是通佩符
<font size="1">2019-12-02 14:29 PM</font>
<hr>

trait 不是 interface
<font size="1">2019-12-02 14:14 PM</font>
<hr>

sudo xattr -d com.apple.quarantine /Applications/xxxx.app
<font size="1">2019-11-30 08:34 AM</font>
<hr>

以后做个医生好不好,不做,做个吉他手呢?不做!做个程序员呢?不做程序员! 做个开钻机的好吗?好!!!!!
<font size="1">2019-11-29 20:22 PM</font>
<hr>

golang只有在gopath中找不到的包路径，才允许用相对路径导入
<font size="1">2019-11-29 08:51 AM</font>
<hr>

A little copying is better than a little dependency.
<font size="1">2019-11-29 08:47 AM</font>
<hr>

每个人自己的经历是天然的最好的故事的素材.
<font size="1">2019-11-28 22:05 PM</font>
<hr>

lime项目 https://github.com/limetext/lime
<font size="1">2019-11-28 18:09 PM</font>
<hr>

vscode如何只读方式打开目录
<font size="1">2019-11-28 17:45 PM</font>
<hr>

vim insert模式下如何跳至行尾
<font size="1">2019-11-28 15:11 PM</font>
<hr>

如果未来大部分的职业被机器所替代,失业这个词要么会消失,要么会被重新定义.
<font size="1">2019-11-28 13:34 PM</font>
<hr>

有点明白科技先哲们所想的未来为什么跟 们不一样了,即使他们立足于更早的过去,设想并为这个设想创造原型是面向未来和大部分人的面向现在是根本不同的.
<font size="1">2019-11-28 13:33 PM</font>
<hr>

MOOC
<font size="1">2019-11-28 13:16 PM</font>
<hr>

米果能对着我的名子念出来,其实是在看图,认中国字就是看图
<font size="1">2019-11-28 13:08 PM</font>
<hr>

原来摄像头在上方看起来还是看着对方的眼睛是通过软件修正的.
<font size="1">2019-11-28 11:51 AM</font>
<hr>

alfred的各个workflow之间也是可以调用的.
<font size="1">2019-11-28 11:20 AM</font>
<hr>

shopt -s nocaseglob  #设置bash下ls大小写不敏感
<font size="1">2019-11-28 10:35 AM</font>
<hr>

QWERTY 的说法并不全面,像er,thy,都是证据
<font size="1">2019-11-27 16:29 PM</font>
<hr>

图灵机可以实现任何计算, "停机问题"证明了不是所有问题都是可以通过计算解决的.
<font size="1">2019-11-27 14:30 PM</font>
<hr>

excute 还有处死的意思,执行(刑),中文里也有这个意思,算是半个外来语.
<font size="1">2019-11-27 10:07 AM</font>
<hr>

你知道别人知道这个事情,但你不知道别人如何理解这个事情.
<font size="1">2019-11-27 09:28 AM</font>
<hr>

计算机科学速成课  https://www.bilibili.com/video/av21376839/
<font size="1">2019-11-26 22:01 PM</font>
<hr>

贷款和投资
<font size="1">2019-11-26 16:23 PM</font>
<hr>

LIBRARY_PATH和LD_LIBRARY_PATH环境变量
<font size="1">2019-11-26 15:59 PM</font>
<hr>

f-string, f"hello,{name}"    python 3.6 引入的
<font size="1">2019-11-26 11:07 AM</font>
<hr>

SMR叠瓦式硬盘,要买的话最好一次性写入数据做存储盘.
<font size="1">2019-11-26 09:01 AM</font>
<hr>

要感谢那些段位完全高于我,还愿意听我说的人.
<font size="1">2019-11-25 12:51 PM</font>
<hr>

iterm2,`⌘+delete` = 0x15  ` ⌥+delete` = 0x17
<font size="1">2019-11-24 17:21 PM</font>
<hr>

大电视,小佩奇 .by米果
<font size="1">2019-11-24 09:56 AM</font>
<hr>

博盐生抽:宁化府陈醋=2:1   这个味道最好
<font size="1">2019-11-23 13:30 PM</font>
<hr>

严重怀疑go语言中的变量类型和返回值类型没有使用冒号是因为冒号真的很不好键入,且又是高频输入:)
<font size="1">2019-11-20 11:04 AM</font>
<hr>

有什么菜,做什么菜,看起来是因果,其实应该反过来理解 ,做什么菜,看有什么菜
<font size="1">2019-11-19 11:27 AM</font>
<hr>
设计nektar se25的人很有自己的一套.
<font size="1">2019-11-18 17:10 PM</font>

<hr>

`Homebrew = [Tap,Formula,Cellar,Keg]`
<font size="1">2019-11-18 17:07 PM</font>
<hr>

Erlang的OTP了解一下
<font size="1">2019-11-18 11:53 AM</font>
<hr>

OTP&MACRO@Elixir
<font size="1">2019-11-18 11:47 AM</font>
<hr>

elixir 念 [ilikser]
<font size="1">2019-11-18 11:40 AM</font>
<hr>

Bing = Bing is not google ,哈哈
<font size="1">2019-11-18 09:12 AM</font>
<hr>

UPX ,压缩可执行文件
<font size="1">2019-11-18 00:23 AM</font>
<hr>

macbook power键接下0.5秒可以关屏
<font size="1">2019-11-17 23:58 PM</font>
<hr>

《Crystal For Rubyists》 - 简体中文 Chinese Version
<font size="1">2019-11-17 23:20 PM</font>
<hr>

三个新的开源编程语言（Coconut, Crystal, Oden）
<font size="1">2019-11-17 23:04 PM</font>
<hr>

[http://coconut-lang.org/](http://coconut-lang.org/),又一门新语言
<font size="1">2019-11-17 23:01 PM</font>
<hr>

Crystal的联合类型是个创新
<font size="1">2019-11-17 22:52 PM</font>
<hr>

`blog t`加了把内容copy一份到clipboard,方便多了,有需求真的不是想出来的,观察重要,观察自己更重要.
<font size="1">2019-11-17 10:10 AM</font>
<hr>

以前在学ruby的时候就冒出个想法,要是能把ruby编译成可直接执行的机器码就好了,这个世界不是你一个人有这个想法,关键是有人还真去做了,这就是crystal语言^-^
<font size="1">2019-11-17 10:06 AM</font>
<hr>

有些语言的类型可以判断,而swift自动引用自己写的类,也是异曲同工吧.
<font size="1">2019-11-17 09:36 AM</font>
<hr>

FPM,python打包工具,打包成一个安装程序
<font size="1">2019-11-16 23:07 PM</font>
<hr>

shell中的try catch  `{ command} || {catch command}`
<font size="1">2019-11-15 22:25 PM</font>
<hr>

当前shell执行文件的绝对路径 `SHELL_FOLDER=$(cd "$(dirname "$0")";pwd)`
<font size="1">2019-11-15 21:48 PM</font>
<hr>

通过wunderlist 这样的数据同步来打通手机与电脑之间的通道是不是可以做一些事情呢?
<font size="1">2019-11-15 13:39 PM</font>
<hr>

file:/// =>  file://  + / (root)
<font size="1">2019-11-15 12:26 PM</font>
<hr>

brew tap jakehilborn/jakehilborn && brew install displayplacer
<font size="1">2019-11-15 09:30 AM</font>
<hr>

macOS command line utility to configure multi-display resolutions and arrangements.[https://github.com/jakehilborn/displayplacer](https://github.com/jakehilborn/displayplacer)
<font size="1">2019-11-15 09:28 AM</font>
<hr>

macOS 的主显示器程序化设置
<font size="1">2019-11-15 09:20 AM</font>
<hr>

A的故事来了 [https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPFrameworks/Concepts/FrameworkAnatomy.html](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPFrameworks/Concepts/FrameworkAnatomy.html)
<font size="1">2019-11-15 05:19 AM</font>
<hr>

export LC_CTYPE=UTF-8
<font size="1">2019-11-14 16:36 PM</font>
<hr>

blog最重要的作用就是把理解的事情用自己的话再讲一次
<font size="1">2019-11-14 14:59 PM</font>
<hr>

苹果的Frameworks中的版本为啥有个 A目录,有什么故事吗?
<font size="1">2019-11-13 23:20 PM</font>
<hr>

```sh 
➜  shims chromedriver
Starting ChromeDriver 79.0.3945.16 (93fcc21110c10dbbd49bbff8f472335360e31d05-refs/branch-heads/3945@{#262}) on port 9515
Only local connections are allowed.
Please protect ports used by ChromeDriver and related test frameworks to prevent access by malicious code.
^C
➜  shims ls ~/.rbenv/versions/*/bin/* | grep chromedriver
/Users/bob/.rbenv/versions/2.5.1/bin/chromedriver
/Users/bob/.rbenv/versions/2.5.1/bin/chromedriver-update
➜  shims ls ~/.rbenv/versions/*/bin/* | grep chromedriver | xargs rm
➜  shims ls ~/.rbenv/versions/*/bin/* | grep chromedriver
➜  shims which chromedriver
/Users/bob/.rbenv/shims/chromedriver
➜  shims which chromedriver | xargs rm
➜  shims which chromedriver
chromedriver not found  
```
<font size="1">2019-11-13 22:02 PM</font>
<hr>



set -x  =====> set +x
<font size="1">2019-11-12 10:19 AM</font>

<hr>

bash的调试真是的烦人的事情
<font size="1">2019-11-12 10:18 AM</font>
<hr>

awk NR FNR NF
<font size="1">2019-11-12 07:06 AM</font>
<hr>

alfred中的python,ruby除了{query}可以在脚里进行替换,其他的变量的使用都需要使用环境变量. `os.environ['varname']`,`ENV['varname']`
<font size="1">2019-11-11 14:11 PM</font>
<hr>

shell - IFS分隔符
<font size="1">2019-11-11 12:26 PM</font>
<hr>

ruby中``执行shell,如果向这个shell 传递参数呢
<font size="1">2019-11-11 11:00 AM</font>
<hr>

图片处理脚本 sips
<font size="1">2019-11-09 23:08 PM</font>
<hr>

Foxmail for mac 针对Catalina还是做了适配
<font size="1">2019-11-09 22:45 PM</font>
<hr>

正则表达式的构建过程应该就是下一代编程的模式
<font size="1">2019-11-09 20:27 PM</font>
<hr>

Catalina对文件系统做了大改造,虽然有firmlink这样的东西,但像afled这样的应用中,仍然有对文件的绝对路径的依赖,问题多多
<font size="1">2019-11-09 08:55 AM</font>
<hr>

今天是你的生日,宝贝.
<font size="1">2019-11-08 12:38 PM</font>
<hr>

想着把一件已经明白的事情讲明白,对这件事情的理解就进入下一个level了
<font size="1">2019-11-08 12:37 PM</font>
<hr>

能方便的独立分发这件事情不只是包装,也意味着更多的生意市场
<font size="1">2019-11-08 12:35 PM</font>
<hr>

准备买一个25欧的软件,很贵,但值得.
<font size="1">2019-11-08 12:34 PM</font>
<hr>

苹果在声音的切换,静音,停止开启播放这件事情上无疑是做的最好的.
<font size="1">2019-11-08 10:06 AM</font>
<hr>

正则表达式是”编译”的结果
输出正则表达式的思路是”源码”
<font size="1">2019-11-08 09:09 AM</font>
<hr>

keynote的左边的目录也可以分级
<font size="1">2019-11-08 09:09 AM</font>
<hr>

git add 是两步,第一步保存文件的内容为新的对象,第二步再把这个对象,权限,文件名登记到index(暂存区)
<font size="1">2019-11-07 16:53 PM</font>
<hr>

哈哈 "南抖音，北快手，智障界，俩泰斗"
<font size="1">2019-11-07 11:28 AM</font>
<hr>

"世界上最坚硬的东西是啥？脸上的胡子！"
<font size="1">2019-11-07 11:27 AM</font>
<hr>

${var}\(试听\).mp3
<font size="1">2019-11-07 09:00 AM</font>
<hr>

CTR预估
<font size="1">2019-11-06 17:53 PM</font>
<hr>

跟图形一样,speeter这样的东西,未来也一定能像图形一样可以做高质量的修复和补充的,这一天不会远的,可是这一天到来的时候,也许这个技术本身的价值就很小了,因为音乐创作的艺术形式可能有新的定义了.
<font size="1">2019-11-06 11:45 AM</font>
<hr>

gitpage罢工了?
<font size="1">2019-11-06 09:14 AM</font>
<hr>

Catalina下的系统zip解压有问题
<font size="1">2019-11-05 22:29 PM</font>
<hr>

`/SystemVolumes/Data`是什么
<font size="1">2019-11-05 17:54 PM</font>
<hr>

`pandas-0.25.1        | 10.2 MB   | ######################9` 进度条也是可以优化的
<font size="1">2019-11-05 16:00 PM</font>
<hr>

补充下一: 还要执行 .bash_profile
<font size="1">2019-11-05 14:19 PM</font>
<hr>

spleeter 无法运行的原因就是conda使用的是bash,而我使用的是zsh
<font size="1">2019-11-05 14:12 PM</font>
<hr>

音轨分离的开源软件来了 [https://github.com/deezer/spleeter](https://github.com/deezer/spleeter)
<font size="1">2019-11-05 09:24 AM</font>
<hr>

"读书的关键，永远不在于「读」，而是在于「想」"
<font size="1">2019-11-04 18:01 PM</font>
<hr>

关键字,关键字,关键字
<font size="1">2019-11-04 15:37 PM</font>
<hr>

类风湿是免疫系统错把友军当敌军,抑郁是不是也是同理?
<font size="1">2019-11-04 14:51 PM</font>
<hr>

"你看不到的缺点，不见得没有，只是你还没看到。"
<font size="1">2019-11-04 14:32 PM</font>
<hr>

过度控制一个复杂的系统最终将走向混乱
<font size="1">2019-11-04 14:30 PM</font>
<hr>

一个乐句跟写一句话一样,也是需要反复的修改才能变得更简单和准确的,很可惜,我一直都没明白这个早就明白的道理 
<font size="1">2019-11-04 14:28 PM</font>
<hr>

movable type,看到这个,恍若隔世,有些事情是任凭你如何聪明也是无法预测未来的.
<font size="1">2019-11-04 14:23 PM</font>
<hr>

那些曾经像常识一样的道理,我现在越来越不敢肯定自己是真的懂了,不清楚是这些道理指导着你走到今天,还是走到今天又开始怀疑这些曾经指引过你的道理....
<font size="1">2019-11-04 13:52 PM</font>
<hr>
问题的关键就在于区分我能和我想做什么了
<font size="1">2019-11-04 13:38 PM</font>

<hr>

被代码编辑器给惯坏了,书上的代码没有颜色都不想看了
<font size="1">2019-11-04 13:37 PM</font>
<hr>

[https://github.com/carrierdown/mutateful](https://github.com/carrierdown/mutateful)
<font size="1">2019-11-04 09:01 AM</font>
<hr>

mutateful就是ableton live的脚本语言呀,秒!
<font size="1">2019-11-04 08:59 AM</font>
<hr>

中国有一千万的自闭症患者...
<font size="1">2019-11-03 23:35 PM</font>
<hr>

自闭症的孩子,看着好心酸.
<font size="1">2019-11-03 23:31 PM</font>
<hr>

nektar se25 不错
<font size="1">2019-11-02 21:38 PM</font>
<hr>

LEGB
<font size="1">2019-11-02 14:13 PM</font>
<hr>

Combine
Customize handling of asynchronous events by combining event-processing operators.
<font size="1">2019-11-02 13:43 PM</font>
<hr>

FCP也挂了
<font size="1">2019-11-01 15:32 PM</font>
<hr>

Catalina里Dashboard没有了??
<font size="1">2019-11-01 15:24 PM</font>
<hr>

Catalina 的系统设置内容分为不见两大类,但看不出分类的维度是什么
<font size="1">2019-11-01 15:00 PM</font>
<hr>

reminder什么时候能增加全局快捷键呢 
<font size="1">2019-11-01 12:32 PM</font>
<hr>

这一次的macOS升级有点早,但问题还好,没想象的多.
<font size="1">2019-11-01 12:31 PM</font>
<hr>

Catalina上的wunderlist 的快捷添加时屏幕会闪一下
<font size="1">2019-11-01 12:31 PM</font>
<hr>

macOS10.15上的阴影更大了, `defaults write com.apple.screencapture disable-shadow -bool true && killall SystemUIServer`
<font size="1">2019-10-31 18:21 PM</font>
<hr>

xcrun其实就像是ruby下的bundle exe
<font size="1">2019-10-31 18:09 PM</font>
<hr>

`drwx------@`中的@是文件附加属性,用xattr进行查看操作,那下面的DMG打开的时候提示从哪下载的信息也一定是存在这里的了:)
<font size="1">2019-10-31 18:06 PM</font>
<hr>
关键时候能救命 `xattr -cr /path/to/application.app`
<font size="1">2019-10-31 18:04 PM</font>

<hr>

156141251
<font size="1">2019-10-30 22:47 PM</font>
<hr>

176543251
<font size="1">2019-10-30 22:35 PM</font>
<hr>

yarn 真的比npm快多了
<font size="1">2019-10-30 20:19 PM</font>
<hr>

sparkle & sentry ,一个是应用更新,一个是异常监控,写macOS项目必备.
<font size="1">2019-10-30 18:37 PM</font>
<hr>

学习吉他就应该弹整首歌,学习编程就应该尝试一个完整的项目.
<font size="1">2019-10-30 17:38 PM</font>
<hr>

.gitignore的参考 [https://github.com/github/gitignore](https://github.com/github/gitignore)
<font size="1">2019-10-29 13:51 PM</font>

<hr>
xcode 注释代码如何能不在行首加`//`呢
<font size="1">2019-10-29 13:20 PM</font>

<hr>
什么是语法糖,其实就是简称啊,米果说的AD糖就是啊
<font size="1">2019-10-29 11:57 AM</font>

<hr>

GCD的设计很显然比GO的协程在执行的顺序和并发的控制上想的要更多一些.要是有更简单的语法糖就好了.
<font size="1">2019-10-29 11:55 AM</font>
<hr>

死锁的产生原因很简单,就是你等我,我等你,最后死等,等死.
<font size="1">2019-10-29 11:24 AM</font>
<hr>

ruby里的小写叫 downcase,因为大写是upcase
<font size="1">2019-10-29 08:56 AM</font>
<hr>

还真有把sh转成二进制的方案, `brew install shc`
<font size="1">2019-10-28 12:29 PM</font>
<hr>

加`""`就可以解决bash中的空格转义问题
<font size="1">2019-10-28 11:34 AM</font>
<hr>

grep中的正则很多要转义
<font size="1">2019-10-28 11:06 AM</font>
<hr>

Alfred的Action为啥不支持搜索过滤呢?这个不科学啊,新版本里应该加上.
<font size="1">2019-10-28 09:12 AM</font>
<hr>

alfred 全局变量也是可以用 {var:var_name}来使用的
<font size="1">2019-10-27 10:41 AM</font>
<hr>

理解相对论的难点就是我们自己无意识的认为时间是个全局变量,而不是变量.
<font size="1">2019-10-26 05:16 AM</font>
<hr>

相对论中的时间快慢都是别人眼中的快和慢,这看起来跟有钱没钱都要死一样,很公平啊
<font size="1">2019-10-26 05:14 AM</font>
<hr>

电吉他琴颈里的钢筋原来是两根条状钢筋组成的,一直以为是一根.
<font size="1">2019-10-26 05:00 AM</font>
<hr>

新版本的 rbenv,pyenv好像已经不需要设置路径 shims了
<font size="1">2019-10-25 14:52 PM</font>
<hr>

"你要相信，以你们的水平，用什么语言都不可维护",哈哈哈!
<font size="1">2019-10-25 14:42 PM</font>
<hr>

哦,`<kbd>command</kbd>` <kbd>command</kbd>
<font size="1">2019-10-25 13:48 PM</font>
<hr>

typora 的网站是托管在github上的
<font size="1">2019-10-25 13:42 PM</font>
<hr>

猜一下,typro中图片缩放设置功能的起源是macbook 的retina屏幕吧
<font size="1">2019-10-25 13:40 PM</font>
<hr>

typro 里面的有squence
<font size="1">2019-10-25 13:28 PM</font>
<hr>

Yaml中的 &default `&`表示定义锚点, `<<: *default` 中的`*`表示引用锚点 ,<< 表示插入引用的内容.这里的 `:` 很容易跟前面的<<在一起造成理解障碍. 
<font size="1">2019-10-25 13:21 PM</font>
<hr>

说不清,听不懂,会错意, 这就是我们现在接口的现状.
<font size="1">2019-10-25 11:53 AM</font>
<hr>

hammerspoon 要想有前途,首先得学一下KM或是alfred的自助式开发环境,否则永远只能在程序员的小圈子里流行了.
<font size="1">2019-10-25 11:48 AM</font>
<hr>

eval就是最好的方法了
<font size="1">2019-10-25 11:47 AM</font>
<hr>

注入代码到当前的shell built in 只能使用eval吗?
<font size="1">2019-10-25 10:08 AM</font>
<hr>

shell里有太多生活事件的影子了
<font size="1">2019-10-25 09:08 AM</font>
<hr>

终于见到正祥真人了:)
<font size="1">2019-10-24 17:45 PM</font>
<hr>

shim
<font size="1">2019-10-24 17:41 PM</font>
<hr>

zsh没有help,但是有 `type -a [command]` 和 `command -V [command]`
<font size="1">2019-10-24 17:20 PM</font>
<hr>

zsh没有help命令
<font size="1">2019-10-24 17:18 PM</font>
<hr>

极：1后48个0，汉族以”极”为最大数，指到最顶最大最边的意思。
<font size="1">2019-10-24 16:22 PM</font>
<hr>

PCRE
<font size="1">2019-10-24 13:37 PM</font>
<hr>

正则里的一些术语如果能换一下,易懂性估计能提升好多.
<font size="1">2019-10-24 11:50 AM</font>
<hr>

"悲观者总是正确，乐观者继续前行。"
<font size="1">2019-10-24 11:24 AM</font>
<hr>
BRE&ERE
<font size="1">2019-10-24 08:55 AM</font>

<hr>
昨晚问米果:"爸爸为什么看着你就高兴呢?"

他说"喜欢!"

这次对话值得记录.

<font size="1">2019-10-23 21:29 PM</font>

<hr>

icu4c 是什么
<font size="1">2019-10-23 21:23 PM</font>
<hr>

微信撤回信息的时候还给了个edit用于编辑撤回的信息,这个设计很好.
<font size="1">2019-10-23 17:45 PM</font>
<hr>

有时候用非XXX方式表示一个状态是非常糟糕的,除非这个描述是一个约定俗成的,正则是的`非贪婪`模式就是个典型,日常生活里压根就没有这种说法,应该叫做最小匹配或最短匹配.
<font size="1">2019-10-23 15:38 PM</font>
<hr>

rubymine终端里创建的的文件是个链接,直接点击就能打开:)
<font size="1">2019-10-23 14:06 PM</font>
<hr>

F12是最后一个窗口,option+F12是终端,所有的Esc都回到编辑器窗口,还是jetbrains的工程师懂工程师
<font size="1">2019-10-23 14:04 PM</font>
<hr>

alfred 的wf应该disable功能,这样才能方便调试
<font size="1">2019-10-23 12:19 PM</font>
<hr>

alfred大小写转换等功能使用transform 模块
<font size="1">2019-10-23 11:39 AM</font>
<hr>

五笔输入法的四字上屏与中英文混输是不可调和的矛盾
<font size="1">2019-10-23 10:38 AM</font>
<hr>

Yacc & Bison
<font size="1">2019-10-23 10:23 AM</font>
<hr>

ripper
<font size="1">2019-10-23 10:15 AM</font>
<hr>

语言中的关键字是不能作为变量使用的,但ruby中可以以@do @@do 的形式存在.
<font size="1">2019-10-23 09:12 AM</font>
<hr>

基本我想到的问题别人都想到了,但是想到才是最重要的,闻道有先后.
<font size="1">2019-10-22 15:30 PM</font>
<hr>

macOS自带截图命名规则如何设置?
<font size="1">2019-10-22 13:31 PM</font>
<hr>

alfred 预览文件 `⌘ + y`
<font size="1">2019-10-22 13:30 PM</font>
<hr>

xtomp中的buffered pass是什么意思
<font size="1">2019-10-21 15:33 PM</font>
<hr>

soundcloud是一个特殊的存在
<font size="1">2019-10-21 15:12 PM</font>
<hr>

www.pgadmin.org
<font size="1">2019-10-21 15:11 PM</font>
<hr>

我们熟悉一个东西的使用,重点不是掌握了更多的信息,而是如何剔除无用信息,再处理剩下的有用信息.
<font size="1">2019-10-21 15:06 PM</font>
<hr>

正则第一个需要了解的概念就是`.`和`\s\S`了吧
<font size="1">2019-10-21 15:03 PM</font>
<hr>

sqlite or firebird
<font size="1">2019-10-21 14:59 PM</font>
<hr>

正则是`.` 之所以不包括换行,应该是大部分的匹配都是以行为单位的吧.
<font size="1">2019-10-21 14:46 PM</font>
<hr>

截图终于可以不再使用第三方的APP了
<font size="1">2019-10-21 11:47 AM</font>
<hr>

关注一下upworks
<font size="1">2019-10-21 09:33 AM</font>
<hr>

当前的这个T,更新较为频繁,其应该有独立的layout,这样生成静态页的时候会减少没有必要页面生成.
<font size="1">2019-10-21 09:32 AM</font>
<hr>

postgresql 在市场营销层要做的第一件事就是改名为 pgsql
<font size="1">2019-10-21 09:28 AM</font>
<hr>

python中的 `if __name__ == "__main__":` ,ruby中可以这样写 `if __FILE__ == $0` 或者 `if __FILE__ == $PROGRAM_NAME`
<font size="1">2019-10-21 09:17 AM</font>
<hr>

ADSR,只有S是一个数值,其他三个是时间的值
<font size="1">2019-10-20 20:44 PM</font>
<hr>

并发测试2
<font size="1">2019-10-18 16:07 PM</font>
<hr>

并发测试1
<font size="1">2019-10-18 16:07 PM</font>
<hr>

escape 已废弃,为啥alfred里还在用?
<font size="1">2019-10-18 16:06 PM</font>
<hr>

vscode 分栏: cmd+[1|2|3], reset: cmd+option+0
<font size="1">2019-10-18 14:31 PM</font>
<hr>

Hammerspoon 有空可以花时间学习一下,看看是否可以加入到三剑客阵营中去,要是能替代KM就更好了,可以省小不一笔钱.
<font size="1">2019-10-18 12:30 PM</font>
<hr>

`which .` .: shell built-in command 
<font size="1">2019-10-18 10:19 AM</font>
<hr>

得好好复盘下正则的学习方法了
<font size="1">2019-10-18 10:18 AM</font>
<hr>

ruby的hash新写法好尴尬 {:key::value}
<font size="1">2019-10-17 17:29 PM</font>
<hr>

Ruby 里的 %Q, %q, %W, %w, %x, %r, %s, %i
<font size="1">2019-10-17 13:37 PM</font>
<hr>

上面说的不是公共模块,而是触发这个wf的pre全局filter,可以用来处理一些环境检查之类的事情.
<font size="1">2019-10-17 11:54 AM</font>
<hr>

`source file`和`. file` 是等价的
<font size="1">2019-10-17 11:37 AM</font>
<hr>

alfred 应该加入公共模块的概念,写完一个wf后,发现要抽象统一行为时太麻烦了.
<font size="1">2019-10-17 11:34 AM</font>
<hr>

ruby 错过大数据实在是太可惜了
<font size="1">2019-10-17 11:32 AM</font>
<hr>

grep统计字符出现的次数要用-o参数 `grep -o '[c]'`
<font size="1">2019-10-17 11:12 AM</font>
<hr>

wunderlist 的数据备份仅在网页端提供
<font size="1">2019-10-17 10:44 AM</font>
<hr>

好奇tmux的原理是什么,回头研究一下.
<font size="1">2019-10-17 10:04 AM</font>
<hr>

音箱休眠的原因找到了,为了整齐把线跟其他的线全部捆在一起造成的.
<font size="1">2019-10-17 08:58 AM</font>
<hr>

ri(ruby index)
<font size="1">2019-10-16 18:10 PM</font>
<hr>

Boss RC-10R 估计得等上海的展览结束了才能铺货了吧
<font size="1">2019-10-16 17:57 PM</font>
<hr>

Launchkey mini 2代的黑键跟白键的压键感完全不一样,不是手感好不好的问题,是不一至,不知道3代这个问题解决没解决.
<font size="1">2019-10-16 17:57 PM</font>
<hr>

音箱不休眠的原因应该是duet2 在电脑休眠时Main Out的右输出还是有信号
<font size="1">2019-10-16 09:53 AM</font>
<hr>

lpf,hpf,低通高通定义很绕,明明高切,低切更形象.
<font size="1">2019-10-15 22:52 PM</font>
<hr>

示波器,频谱分析
<font size="1">2019-10-15 22:48 PM</font>
<hr>

米果说:"小佩奇"
<font size="1">2019-10-15 21:20 PM</font>
<hr>

真力8010A的左边的箱子死活不休眠,调个个,还是左边,那应该不是音箱的事了,线?声卡嫌疑最大
<font size="1">2019-10-15 20:29 PM</font>
<hr>

换弦是个体力活,目前最喜欢这个尺寸 0.(10,13,17,26,36,46)
<font size="1">2019-10-15 15:54 PM</font>
<hr>

一个单词不被换行中断 `white-space: nowrap;`
<font size="1">2019-10-14 16:44 PM</font>
<hr>

keynote 里的自由线条缺少垂直水平的提示,画线的时候很难保证水平和垂直.
<font size="1">2019-10-14 16:16 PM</font>
<hr>

\`[shell command]\`是ruby执行shell最方便的方法了吧.
<font size="1">2019-10-14 11:51 AM</font>
<hr>

[ ! -e path/to/file ] && echo 'not exists'
<font size="1">2019-10-14 11:49 AM</font>
<hr>

alfred中的terminal一直没找到如何传递全局变量的方法.今天发现可以通过run script组件直接将变量的值输出到terminal,terminal组件中直接接收{query}就可以了. 哈哈,简单的事情搞复杂了.
<font size="1">2019-10-13 22:06 PM</font>
<hr>

准备入手一块 hotone xtomp,看评测很cool啊
<font size="1">2019-10-13 08:29 AM</font>
<hr>

shell变量替换:  $(echo $var)
<font size="1">2019-10-12 17:24 PM</font>
<hr>

vscode中的终端为啥跟iterm2行为不一样,是有独立的配置吗?
<font size="1">2019-10-12 10:28 AM</font>
<hr>

刷公交卡时,iPhone对正在播放的音频和视频的处理方法不同,音频会降低音量,而视频会暂停播放,刷完后会继续播放,赞!
<font size="1">2019-10-12 10:21 AM</font>
<hr>

喜欢jekyll甚于hexo
<font size="1">2019-10-11 13:48 PM</font>
<hr>

解决提出的问题,还是解决提出问题的人,这是一个问题
<font size="1">2019-10-11 08:45 AM</font>
<hr>

"幽默是解决悲伤的工具,也是解决问题的工具"
<font size="1">2019-10-11 08:44 AM</font>
<hr>

gitalk 真是个好的创意
<font size="1">2019-10-10 20:46 PM</font>
<hr>

人声录音最需要解决的问题就是出错后打点并如何自动化剪辑这些出错的段落.
<font size="1">2019-10-10 17:17 PM</font>
<hr>

CTR(点击通过率)
<font size="1">2019-10-10 16:46 PM</font>
<hr>

macOS的共享剪切板的功能设置在设置的general里
<font size="1">2019-10-10 10:03 AM</font>
<hr>

Google Fi
<font size="1">2019-10-10 08:48 AM</font>
<hr>

"浅水游弋,搬砖打杂"
<font size="1">2019-10-09 10:39 AM</font>
<hr>

"就算有天我们被生活揍得睁不开眼"
<font size="1">2019-10-09 08:50 AM</font>
<hr>

kantana 100的line out是非平衡的,并且包括周边效果的.如果只录前级的话,要从send口接声卡,软件内要考虑接后级及箱体模拟.
<font size="1">2019-10-08 18:20 PM</font>
<hr>

irb实际上是把控制台的输入送给eval()方法执行 #ruby
<font size="1">2019-10-08 17:55 PM</font>
<hr>

ruby的around alias的想法是不是就是来自于通过临时变量交易两个变量值
<font size="1">2019-10-08 17:42 PM</font>
<hr>

"CSS 世界的诞生就是为图文信息展示服务的"
<font size="1">2019-10-08 16:38 PM</font>
<hr>

猜想:无线耳机右耳耗电会比较多,大多数情况下音乐右声道信息较多一些.
<font size="1">2019-10-08 16:37 PM</font>
<hr>

2016年后的macbook 把耳机口放在右边是个极不便的设计 ,对于大多数习惯右手的来说,右边会放鼠标.
<font size="1">2019-10-08 13:20 PM</font>
<hr>

韩国地铁里的每一个站都有独立的数字编号,2号线就以2开头的3位数,并且站的几个出口都用1,2,3,4来标识,这样真的非常方便. 国内的地铁东南口还是ABCD相比起来都不是好的设计.
<font size="1">2019-10-08 10:39 AM</font>
<hr>

相对路径绝对路径的概念在某个层面有点像音乐里的首调和固定调
<font size="1">2019-10-08 09:28 AM</font>
<hr>

boss rc10r 搭个 oc-3还是挺不错的.
<font size="1">2019-10-08 08:46 AM</font>
<hr>

Supro 1605R,5w的电子管音箱
<font size="1">2019-10-04 16:18 PM</font>
<hr>

Permanent Record
<font size="1">2019-10-03 00:51 AM</font>
<hr>

[机器与人类视觉能力的差距](http://www.yinwang.org/blog-cn/2019/09/16/machine-vs-human-3)
<font size="1">2019-10-03 00:48 AM</font>
<hr>

:/ （这是米果发的）
<font size="1">2019-10-02 10:30 AM</font>
<hr>



**总结的很到位!!!**

"我觉得理解元编程，应该从三个方面来： 

1 理解ruby的方法调用，实际上就是一个消息传递， self，就是指receiver，你应该知道什么情况下，谁是那个消息的receiver。 

2 方法调用链。 你应该了解Ruby中方法寻找的过程。 

3 理解Ruby中的对象模型以及单例类，了解Ruby内建的方法哪些是操作单例类的，比如extend， 我们可以从api文档里面就看到了，它是操作单例类的。
从以上三个层面着手，到最后你也会得到一个归纳总结的结论，self。"   


<font size="1">2019-10-01 23:36 PM</font>

<hr>

"类方法的实质就是一个类的单件方法" #ruby
<font size="1">2019-10-01 22:25 PM</font>
<hr>

eigenclass之所以叫做单件类,是因为它只有一个实例 #ruby
<font size="1">2019-10-01 13:30 PM</font>
<hr>

组合接口的高阻乐器加48V会有影响吗?不知道是不是从设计上就可以解决问题了
<font size="1">2019-09-30 11:00 AM</font>
<hr>

程序会在三个地方关闭前一个作用域同时打开新的作用域. 1.类定义 2模块定义 3方法 #ruby
<font size="1">2019-09-29 13:19 PM</font>
<hr>

"任何情况下你都不要对一个新结识的人给予过高的赞誉，否则，你很可能会大失所望，并且，你会因此而惭愧甚至受到某种伤害。"
<font size="1">2019-09-29 09:58 AM</font>
<hr>

jetbrains系的插件安装直接拖拽文件到窗口就可以了,体验优化无处不在,赞.
<font size="1">2019-09-29 09:42 AM</font>
<hr>

"任何人，从来没有同时去向两个方向的能力，那样除了让人跌倒，不会有其他结果。"
<font size="1">2019-09-29 09:02 AM</font>
<hr>

有空了解一下 bootsnap项目
<font size="1">2019-09-28 22:20 PM</font>
<hr>

长草 tone king
<font size="1">2019-09-28 22:15 PM</font>
<hr>

"github是一个闭源软件,同时是一个开源社区平台:)"
<font size="1">2019-09-28 14:32 PM</font>
<hr>

copyright vs copyleft
<font size="1">2019-09-28 14:29 PM</font>
<hr>

不知道karabiner中的toggle状态显示窗口怎么实现
<font size="1">2019-09-27 23:57 PM</font>
<hr>

很多吉他初学者对前级,后级,箱体的理解错误并不是理解和学习能力的问题,实在是乱七八糟的错误文章太多了
<font size="1">2019-09-27 22:23 PM</font>
<hr>

ruby的对象和类要看上下文理解,类的本身也是一个对象,类的实例也是一个对象,有点绕
<font size="1">2019-09-27 13:19 PM</font>
<hr>

模具和产品这样的类比逻辑对于不同语言的对象和实例的设计及实现是有影响的.
<font size="1">2019-09-27 11:13 AM</font>
<hr>

ruby里的类只是增强的Module,增加了new,allocate,superclass三个方法而已
<font size="1">2019-09-27 11:00 AM</font>
<hr>

视频在某些层面是比文字更精确的表达方式
<font size="1">2019-09-27 10:46 AM</font>
<hr>

ruby元编程书里的实例变量应该变成实例成员变量才更好理解
<font size="1">2019-09-27 10:44 AM</font>
<hr>

新买的Tele接BiasFX2效果还不错,暂时不再打算买57的mic了
<font size="1">2019-09-26 22:41 PM</font>
<hr>

"Matchless Hot Box 3极力推荐这个前级，本身的clean和overdrive音色都十分华丽。同时也是很好的一个单块平台"
<font size="1">2019-09-26 18:01 PM</font>
<hr>

用习惯了0.10的弦,0.09的总不得劲
<font size="1">2019-09-26 18:00 PM</font>
<hr>

vim是孙悟空,emacs是如来,跟手掌心没关系.大部分人好像还是喜欢这只猴子.
<font size="1">2019-09-26 17:18 PM</font>
<hr>

补充: c和d是一对,跟w,aw等打配合.这是我的新发现吗?
<font size="1">2019-09-26 17:13 PM</font>
<hr>

纠正:cc和dd是一对, C和D是一对,s和x才是一对,S是cc的别名,这样就清楚多了.键盘位置上就是上下楼的关系:P
<font size="1">2019-09-26 17:01 PM</font>
<hr>

cc和dd是一对, C和D是一对,d和x是一对
<font size="1">2019-09-26 16:57 PM</font>
<hr>

``和$() 后者支持嵌套
<font size="1">2019-09-26 16:45 PM</font>
<hr>


为啥没有人照着ruby的语法语义去造一门静态语言呢?道理我都懂#@!$#!@
<font size="1">2019-09-26 14:07 PM</font>
<hr>

cpgz和zip是什么关系
<font size="1">2019-09-26 10:47 AM</font>
<hr>

ico是位图
<font size="1">2019-09-26 10:26 AM</font>
<hr>

iterm2下irb中方向键显示^[[A,什么鬼
<font size="1">2019-09-26 10:08 AM</font>
<hr>

电吉他录音时通过音箱拾音也要同时录一轨干琴,便于后期处理
<font size="1">2019-09-26 09:54 AM</font>
<hr>

iOS13音量调节那个又大又影响屏幕的大喇叭终于归到边上了, 这是不是说视频还将持续热下去啊
<font size="1">2019-09-25 18:00 PM</font>
<hr>

youtube的推荐算法还是有问题的,总是根据我看过的收藏的进行推荐,导致看的东西的范畴越来越窄
<font size="1">2019-09-25 17:52 PM</font>
<hr>

ruby就应该对照着java来学习才对味,都是面向对象,但是语义,味道都太不一样了
<font size="1">2019-09-25 17:48 PM</font>
<hr>


不明白App启动广告的跳过按钮位置一直不停的变来变去,是为了让你跳不过?跟软件卸载卸不掉一个路数?
<font size="1">2019-09-25 08:57 AM</font>
<hr>

iOS13来了
<font size="1">2019-09-24 20:44 PM</font>
<hr>

忽视是一种暴力
<font size="1">2019-09-24 20:26 PM</font>
<hr>

"乔布斯在斯坦福毕业典礼上的演讲：你不可能从现在预测到未来，只有回头看时，才会发现事物之间的联系。所以你必须相信，那些生命中的点点滴滴，将会在你未来的生命里，以某种方式串联起来。你必须始终相信一些东西——你的勇气、宿命、生活、因缘，随便什么，它们将给你追寻内心真正所想的自信，带你走离平凡，变得与众不同"
<font size="1">2019-09-24 18:22 PM</font>
<hr>



Go的编译速度基本可以当脚本语言来使了
<font size="1">2019-09-24 17:59 PM</font>
<hr>
因为目光被那些漂亮的言论所吸引,被那些漂亮的站位所吸引,却极少考虑一下你在网上看到的东西,对现实有多大的贡献,在多大的程度上可以应用到生活中去.  --和菜头
<font size="1">2019-09-24 17:44 PM</font>

<hr>

买了一把蓝色的Fender tele,终于没舍得下手Elite.
<font size="1">2019-09-24 16:44 PM</font>
<hr>



绿洲APP内测了,张亚东也在上面发了一些自己弹琴的视频.
<font size="1">2019-09-24 16:17 PM</font>
<hr>
[bash圣经](https://github.com/dylanaraps/pure-bash-bible/blob/master/README.md) [](https://github.com/dylanaraps/pure-bash-bible/blob/master/README.md)
<font size="1">2019/09/23 11:46 PM </font>


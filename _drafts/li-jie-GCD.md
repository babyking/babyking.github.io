---
typora-root-url: ../
typora-copy-images-to: ../image
layout: post
title: 理解GCD
date: 2019-10-28 21:53
category: 开发 
tags: [gcd]
---



>理解要点
>
>1. 队列有两种,串行和并行,队列的理解主要就是任务的供给方式.串行同时只能提供一个任务,并行同时可以提供多个任务(如果有多个任务的话,如果当前队列只有一个任务,就跟串行一样了). 串行跟并行队列跟执行多个任务并不直接相关,执行单个还是多个任务是由执行任务的同步和异步来决定
>
>2. 执行任务分为同步和异步. 
>
>   同步执行,在当前线程(不新建线程),无论是在串行还是并行,都只能一个一个执行任务,一个执行完下再执行一下个任务
>
>   异步,新建线程,新建线程的数量取决于提供任务的队列,如果是串行队列,那就新建一个线程,并且开始顺次执行队列中的任务.  能否确认这里的顺次执行等同于同步执行串行队列? 除了是新建线程
>
>   能等同,因为为了执行这个串行队列中的任务,新开了线程,这里的异步主要就是体现在新建的线程相对于主线程来说的
>
>   同步和异步的理解
>
>   同步一个串行线程和并行线程基本没区别,区别最多的情况就是多个任务在串行和并行队列中的排列不同,而导致执行时候的顺序有可能不同.
>
>   异步一个串行线程和并行线程有区别,异步一个串行线程是开一个新线程来执行串行队列任务,而异步一个并行线程是开多个线程同时执行
>
>   异步是相对于当前的主线程来讲的.
>
>3. 死锁
>
>   死锁的根本原因就是你等我,我等你,最后等死.
>
>   同步加入一个任务A至串行队列,如果这时候发现当前线程正在执行任务就是暂停调度队列中的任务(包括加入任务),等待当前线程空闲时再恢复调度,而当前的同步加入一个任务A因为暂停调度队列也就没办法执行完而阻塞. 这样两边就都在等对方,   队列因主线程的正在忙事情(加入任务到队列)暂停调度然后等主线程空闲,主线程等队列恢复调度好完成自己的任务加入,互相等对方.
>
>   
>
>   ```objc
>   - (void)syncMain{
>       
>       dispatch_queue_t queue = dispatch_get_main_queue();
>       
>       NSLog(@"taskA-%@",[NSThread currentThread]);
>       
>       dispatch_sync(queue, ^{
>           NSLog(@"taskB-%@",[NSThread currentThread]);
>       });
>       
>       NSLog(@"taskA-End-%@",[NSThread currentThread]);
>   }
>   
>   
>   ```
>
>   syncMain 本身就是main_queue里的一个任务,姑且叫A,这个A任务执行过程中又往main_queue里加入了同步任务B,因为是同步的, 所以这个时候A必须等着B执行完成,才能继续执行A并结束,而B是在串行队列min_queu中后加进去的任务,必须等到前面的任务A执行完才能执行,死锁就产生了.
>
>   死锁产生的条件就是  一个串行队列中的同步任务在执行过程中,又往这个串行队列中加了另一个另步任务,这两个任务都在等着对方完成才能继续.这就是死锁.
>
>   
>
>   当前UI主线程执行的任务就是 dispatch_get_main_queue 这个队列里的任务,这个容易被忽略 
>
>   
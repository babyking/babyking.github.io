---
typora-root-url: ../
typora-copy-images-to: ../image
layout: page 
title: "一个人推"
permalink: /t/2022/
date: 2022-01-01 00:00
---

方法、技巧、人脉，都是下乘。上乘智慧是信念。
方法会错、技巧会失效、人脉会散，只有信念永恒。
方法论解决执行问题，信念解决动力问题。
<font size="1">2022-09-28 07:02 AM</font>
<hr>

市场上已经存在的一些IAP的三方库,譬如RMStore、 IAPHelper等
<font size="1">2022-09-27 15:57 PM</font>
<hr>

#第一步把ios文件转成UDRW可写到U盘的的格式
#使用dd把UDRW 写到u盘中去

hdiutil convert -format UDRW -o destination_file.img source_file.iso 

dd if=destination_file.img.dmg of=/dev/disk2 bs=1m  #制作启动u盘
<font size="1">2022-09-26 09:49 AM</font>
<hr>

vi中加注释本质 就是列操作, ^+v -> 选择列 -> 大写I(nsert) -> 插入注释符号 -> ESC 完成 #vi
<font size="1">2022-09-26 09:35 AM</font>
<hr>

rbenv 或是其他第三方版本的ruby使用SSL都有异常,只有系统自带的正常 #ruby #ssl
<font size="1">2022-09-26 08:53 AM</font>
<hr>

swiftui 在xocde中的格式化很有讲究,只格式化竖排,像if else在一行则不会格式 化,这个真的是好很的策略,有些代码一行会更好看一些 #swiftui #代码格式化
<font size="1">2022-09-17 08:57 AM</font>
<hr>

<https://mywiki.wooledge.org/BashGuide> 学习bash的教程
<font size="1">2022-09-16 13:46 PM</font>
<hr>

task 运行的线程
使用 task 修饰器在视图中创建异步任务，除了方便使用基于 async/await 语法的 API 外，开发者也希望能够让这些任务运行在后台线程中，以减少主线程的负担。

非常遗憾，当前上文中所有的使用 task 创建的异步任务都是运行在主线程当中的
<font size="1">2022-09-13 20:16 PM</font>
<hr>

让复杂的任务仅执行一次
但是，onAppear 或 task 也并非只会执行一次，如何保证让某些负担较重的任务只在页面中执行一次呢？利用@State 的生命周期同视图的生命周期一致的特性，便可以很好的解决这个问题。#swiftui
<font size="1">2022-09-13 16:59 PM</font>
<hr>

密码锁 5624
<font size="1">2022-09-09 20:53 PM</font>
<hr>

su 命令与 su - 命令之间有什么区别呢？前者在切换到 root 用户之后仍然保持旧的（或者说原始用户的）环境，而后者则是创建一个新的环境（由 root 用户 ~/.bashrc 文件所设置的环境），相当于使用 root 用户正常登录（从登录屏幕登录）#linux
<font size="1">2022-09-06 23:54 PM</font>
<hr>


UTM,一个iOS,macOS的模拟器,可以运行widnows<https://github.com/utmapp/UTM>
<font size="1">2022-09-01 10:57 AM</font>
<hr>

同步执行的闭包无须 @escaping 修饰；异步执行的闭包必须使用 @escaping 修饰。
无法得知闭包何时执行，也需要使用 @escaping 修饰。
使用 @escaping 修饰的闭包，编译器会强制你显式的使用 self，从而避免代码出错的概率，从而提高代码质量。
#swift
<font size="1">2022-08-29 17:38 PM</font>
<hr>

不是用 IP 访问就要写死 IP 的。你把程序写成先从一个域名解析出 IP 地址，然后用那个 IP 地址直接进行访问就行了，域名只用来确定 IP
<font size="1">2022-08-28 22:44 PM</font>
<hr>

mysql 中的字符集utf8mb4  mb4是 most bytes 4 #mysql
<font size="1">2022-08-26 09:44 AM</font>
<hr>

go中包的使用有两点要注意,import 中写的是跟目录相关,跟包名并无关系(虽然建议一致), 而使用包中的方法前缀,却是真正的包名 #go
<font size="1">2022-08-25 16:15 PM</font>
<hr>

一个方便开发go程序的工具 监视文件修改，然后编译go程序并自动运行。<https://github.com/zxysilent/fish>
<font size="1">2022-08-24 17:23 PM</font>
<hr>

<https://github.com/zxysilent/fish%20fish%20%E6%98%AF%E4%B8%80%E4%B8%AA%E6%96%B9%E4%BE%BF%E5%BC%80%E5%8F%91go%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B7%A5%E5%85%B7%20%E7%9B%91%E8%A7%86%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9%EF%BC%8C%E7%84%B6%E5%90%8E%E7%BC%96%E8%AF%91go%E7%A8%8B%E5%BA%8F%E5%B9%B6%E8%87%AA%E5%8A%A8%E8%BF%90%E8%A1%8C%E3%80%82>
<font size="1">2022-08-24 17:23 PM</font>
<hr>

小米电视型号 L32M5-AZ
<font size="1">2022-08-24 15:29 PM</font>
<hr>

tensorflow for arm  <https://pypi.org/project/tensorflow-aarch64/>
<font size="1">2022-08-24 15:22 PM</font>
<hr>

Fabfilter 音频插件
<font size="1">2022-08-24 09:54 AM</font>
<hr>

siri挺智能,晚上12点多让他明天提醒我早起,他会问是今天还是明天? 聪明 #siri
<font size="1">2022-08-24 00:29 AM</font>
<hr>

MAC下双显如何屏蔽HDMI音频输出端,安装open core引导在dsdt里把hdmi音频屏蔽了
<font size="1">2022-08-23 15:33 PM</font>
<hr>

知道生命无意义,才可以怀着本心生活,就像不用为了考试的学习一样,才会有乐趣可言
<font size="1">2022-08-11 14:03 PM</font>
<hr>

你可以将azw3理解为亚马逊给mobi格式的电子书加了一个「壳」，目的是为了保护电子书版权（DRM保护）
<font size="1">2022-08-04 15:52 PM</font>
<hr>

看完触不可及,再听无人知晓~~
<font size="1">2022-08-07 23:57 PM</font>
<hr>

<https://moises.ai/> 又一个去除人声的软件
<font size="1">2022-08-03 23:25 PM</font>
<https://as.dogged.cn> 切换 App Store
<font size="1">2022-07-28 13:54 PM</font>
<hr>

习惯是如此之轻，以至于无法察觉。又是如此之重，以至于无法挣脱。
——沃伦·巴菲特
<font size="1">2022-07-27 21:59 PM</font>
<hr>

de·cay | dəˈkā |
<font size="1">2022-07-27 15:13 PM</font>
<hr>

ADSR envelope (attack decay sustain release)
<font size="1">2022-07-27 15:12 PM</font>
<hr>

 声音控制键盘
    * 向左,向右 映射到键盘左右方向键,控制游戏 #idea

<font size="1">2022-07-25 17:06 PM</font>
<hr>

在线卖软件app <https://flippa.com/> 
<font size="1">2022-07-25 16:02 PM</font>
<hr>

歌曲速度 BPM Analyser  #keyword
<font size="1">2022-07-25 15:34 PM</font>
<hr>

FCP 网络游戏免费模式 (Free-to-play) #keyword
<font size="1">2022-07-19 17:40 PM</font>
<hr>

Magic Tray Pro  键盘与trackpad 组合成笔记本键盘布局 #设备
<font size="1">2022-07-19 15:49 PM</font>
<hr>

<https://youglish.com/>
Youglish是一款学习外语发音辅助工具，简单来说一款利用Youtube的视频资源查找单词发音的工具。 Youtube很多视频都有文字稿（transcript）， YouGlish就是利用这些文字稿帮助你进行搜索，想学习什么单词的发音，输入搜索即可找出该单词的母语发音者片段，重读收听练习，目前该网站一键支持全球18种语言，A姐觉得，如果你是中文用户的话，又学习英语发音，那么这款工具一定非常适合你，Youglish确实是一个非常好的外语发音辅助工具。 #英语 刚想到的,你说我们身上整一个24小时录音的设备,把自己一个星期或是一个月生活中所有的对话全都录下来,然后把这些对话全部整理成材料, 然后呢把这些对话全部转换成英文学习,吃透,是不是英语就没啥问题了? #idea
<font size="1">2022-07-15 11:21 AM</font>
<hr>

<https://youglish.com/>
Youglish是一款学习外语发音辅助工具，简单来说一款利用Youtube的视频资源查找单词发音的工具。 Youtube很多视频都有文字稿（transcript）， YouGlish就是利用这些文字稿帮助你进行搜索，想学习什么单词的发音，输入搜索即可找出该单词的母语发音者片段，重读收听练习，目前该网站一键支持全球18种语言，A姐觉得，如果你是中文用户的话，又学习英语发音，那么这款工具一定非常适合你，Youglish确实是一个非常好的外语发音辅助工具。 #英语
<font size="1">2022-07-15 11:17 AM</font>
<hr>

混音师网站 <https://mixwiththemasters.com/>
<font size="1">2022-07-12 10:32 AM</font>
<hr>

电影打卡板
<font size="1">2022-07-10 19:50 PM</font>
<hr>

* 自然语言描述转成正则表达式 <https://www.autoregex.xyz/>
<font size="1">2022-07-09 23:27 PM</font>
<hr>

<http://enpuz.com/> #英语
<font size="1">2022-07-09 21:11 PM</font>
<hr>

方形显示器 lg 28mq780 #显示器
<font size="1">2022-07-08 16:26 PM</font>
<hr>

How to detect Chords from audio github  #keywords #关键字
<font size="1">2022-07-07 17:26 PM</font>
<hr>

I帧 、P帧、B帧, I是关键帧,包含全部信息,P帧记录与前一帧的差别,B帧记录前与后帧差别. P帧压缩率相对于B帧低,但解码相对容易 #视频 #ffmpeg
<font size="1">2022-07-06 16:48 PM</font>
<hr>

相当于teenage op-1的开源版本ttps://github.com/FundamentalFrequency
<font size="1">2022-06-28 09:26 AM</font>
<hr>

前端精读<https://github.com/ascoders/weekly>
<font size="1">2022-06-25 22:53 PM</font>
<hr>

<https://github.com/ascoders/weekly>
<font size="1">2022-06-25 22:52 PM</font>
<hr>

免费编程电子书 <https://ebookfoundation.github.io/free-programming-books/books/free-programming-books-zh.html>
<font size="1">2022-06-25 22:46 PM</font>
<hr>

听话和相信是没有关系的
<font size="1">2022-06-24 10:16 AM</font>
<hr>

人生四个阶段，不想上学、不想上班、不想上医院、不想上西天。
<font size="1">2022-06-23 13:58 PM</font>
<hr>

随机生成人照片 <https://generated.photos/>
<font size="1">2022-06-21 17:18 PM</font>
<hr>

说机不说吧，文明你我他。
<font size="1">2022-06-20 23:02 PM</font>
<hr>

桌机,家机
<font size="1">2022-06-20 23:00 PM</font>
<hr>

iptv搜索引擎 <https://www.foodieguide.com/iptvsearch/>
<font size="1">2022-06-17 06:53 AM</font>
<hr>

airdrop 原来可以复制一段文本传送, 传送过去会生成文件类型为文本剪辑的文件文件扩展名为 .textClipping #mac
<font size="1">2022-06-16 17:40 PM</font>
<hr>

airdrop 原来可以复制一段文本传送, 传送过去会生成文件类型为文本剪辑的文件 #mac
<font size="1">2022-06-16 17:39 PM</font>
<hr>

出口合规证明信息 ITSAppUsesNonExemptEncryption NO
<font size="1">2022-06-14 16:49 PM</font>
<hr>

app图标宽度为64,里面的尺寸为50 #ios #设计
<font size="1">2022-06-13 10:20 AM</font>
<hr>

app图标的圆边角尺寸为10 #ios
<font size="1">2022-06-13 10:19 AM</font>
<hr>

potatso (shadowsocks)  ios vpn app #ios
<font size="1">2022-06-12 09:19 AM</font>
<hr>

因为人本身就是目的
<font size="1">2022-06-11 22:46 PM</font>
<hr>

音频转midi <https://basicpitch.spotify.com/>
<font size="1">2022-06-09 21:10 PM</font>
<hr>

swiftui 窗口定位<https://www.woodys-findings.com/posts/positioning-window-macos>
<font size="1">2022-06-08 15:13 PM</font>
<hr>

<https://github.com/azuwis/pianotrans>
<font size="1">2022-06-08 00:12 AM</font>
<hr>

把钢琴音频转成midi的项目 <https://github.com/bytedance/piano_transcription>
<font size="1">2022-06-08 00:07 AM</font>
多屏显示切换在hammerspoon实现的另一种思路:  多屏显示器显示排列模式只用一种,比如左右. 无论显示器实际怎么摆放,只需要一种配置就可以轮流切换,唯一缺点就是只能通过键盘来切换,如果左右模式与实际的显示器排列位置不同,鼠标拖动窗口则不可行. 但平时很少用鼠标来做这件事情,所以也不失为一种简单粗暴有效的解决方法 #hammerspoon 
<font size="1">2022-06-06 10:51 AM</font>
<hr>

opt+\=«, opt+shift+\ = »,   opt+< = ≤, opt +> = ≥  #特殊符号 
<font size="1">2022-05-30 18:49 PM</font>
<hr>

bazel 使用 starlark 作为构建语言,类似于python
<font size="1">2022-05-27 00:15 AM</font>
<hr>

google翻译AI <https://cloud.google.com/translate/>
<font size="1">2022-05-27 00:12 AM</font>
<hr>

智能反跟踪 ITP #ios
<font size="1">2022-05-26 10:24 AM</font>
<hr>

飞书为啥用 lark作为英文名
<font size="1">2022-05-25 08:36 AM</font>
<hr>

后之视今，亦犹今之视昔。悲夫！——王羲之
<font size="1">2022-05-25 08:28 AM</font>
<hr>

折分pdf 在preview里非常简单,直接把目录中选中的页面拖到目录里就可以了 #拆分pdf
<font size="1">2022-05-24 16:26 PM</font>
<hr>

史学家黄仁宇曾经说过，学术研究的意义不在发现和批评荒谬， 而在发掘和解释荒谬背后的逻辑
<font size="1">2022-05-22 09:20 AM</font>
<hr>

swift中的 //MARK:   相当于 objc中的 #programa mark. 
<font size="1">2022-05-20 18:17 PM</font>
<hr>

ffmpeg视频变速 <https://zhuanlan.zhihu.com/p/359235727>
<font size="1">2022-05-16 21:26 PM</font>
<hr>

swift里 //MARK: 注释 相当于以前的objc中的 #program mark #swift
<font size="1">2022-05-16 09:56 AM</font>
<hr>
if let 和 guard let 是反义词 #swift
<font size="1">2022-05-14 23:08 PM</font>

<hr>


```swift
if let nameNew = name, let ageNew = age {
    // 进入分支后,nameNew 和 ageNew 一定有值
    print(nameNew + String(ageNew)) // 输出:老王10
}  if let可以有多个值  #swift
```
<font size="1">2022-05-14 23:06 PM</font>

<hr>


Xcode 13 Swift UI项目默认不会使用Info.Plist文件。
<font size="1">2022-05-12 18:45 PM</font>
<hr>

定制外设 <https://monogramcc.com/>
<font size="1">2022-05-11 11:54 AM</font>
<hr>

let bridge = PointerBridge()
let theInt = bridge.getCountPtr()
print(theInt.memory) // 23

let newIntPtr = UnsafeMutablePointer<Int32>.alloc(1)
newIntPtr.memory = 100
bridge.setCountPtr(newIntPtr)

print(theInt.memory) // 100.  swift 调用objc ,参数是指针,引用 #swift
<font size="1">2022-05-10 21:39 PM</font>
<hr>

@rpath。这个就是今天要介绍的重点，它是run path的缩写。本质上它不是一个明确的path，甚至可以说它不是一个path。它只是一个变量，或者叫占位符。这个变量通过XCode中的run path选项设置值，或者通过install_name_tool的-add_rpath设置值。设置好run path之后，所有的@rpath都会被替换掉。此外，run path是可以设置多个值的，这样看来就和Windows下的PATH变量差不多了。run path指定的多个值就可可以完美解决掉参考链接中说的问题了。 #macos #lib
<font size="1">2022-05-09 14:15 PM</font>
<hr>

@rpath。这个就是今天要介绍的重点，它是run path的缩写 #macos
<font size="1">2022-05-09 14:14 PM</font>
<hr>

Mac OS X下二进制可执行文件的动态链接库是dylib文件。

所谓dylib，就是bsd风格的动态库。基本可以认为等价于windows的dll和linux的so。mac基于bsd，所以也使用的是dylib。

Linux下用ldd查看，苹果系统用otool  #macos
<font size="1">2022-05-09 14:09 PM</font>
<hr>

KAWTRdA3UU8QcG install_name_tool - change dynamic shared library install names
<font size="1">2022-05-09 00:52 AM</font>
<hr>

在iOS项目打包时，有两个版本号，一个是Version，即显示在AppStore中的版本号，其key为CFBundleShortVersionString，另一个是Build，即编译版本号，其key为CFBundleVersion。
<font size="1">2022-05-07 11:28 AM</font>
<hr>

双击option键来切换应用内的窗口,像cmd tab一样的效果,开始想复杂了,总想着用karabiner中的变量来实现,有点复杂 .后来直接用alfred中的双击option来触发,通过创建删除文件来做开变量,调用 keyboardmaestro来触发按键   #解决问题
<font size="1">2022-05-06 01:13 AM</font>
<hr>

Task中使用闭包范围内的变量一定要是 let不可变,或是@sendabale,否则 Task认为是不安全的,编译不过 #swift
<font size="1">2022-05-03 18:49 PM</font>
<hr>

JUCE是什么?
<font size="1">2022-05-01 23:45 PM</font>
<hr>

^在swift里是位异或运行算符 #swift
<font size="1">2022-04-30 00:25 AM</font>
<hr>

ForEach 中的 \.self 其实是对元素做的一个hash来做为元素的唯一标识 #swiftui
<font size="1">2022-04-29 19:05 PM</font>
<hr>

状态栏高度 let height = view.window?.windowScene?.statusBarManager?.statusBarFrame.height ?? 0  #swift #swiftui
<font size="1">2022-04-29 14:09 PM</font>
<hr>

swiftui中的padding 实际上还是在元素的下面加了一层,让元素在加的这一层进行padding,其实更像margin #swiftui
<font size="1">2022-04-29 14:02 PM</font>
<hr>

swiftui中的frame中的width和height都可以为nil，如果为nil，就直接使用父view的size #swiftui
<font size="1">2022-04-29 10:41 AM</font>
<hr>

iOS 14.0 下的新框架UniformTypeIdentifiers  (UTI) 
<font size="1">2022-04-27 09:18 AM</font>
<hr>

iOS里的文件分享, imported type identifiers和exported type identifiers是定义自己的类型,输入是可以打开别人的文件,输出是自己创建的文件, 这两个定义好了,并不能代表你的app能处理,还需要在 Document Types里注册定义,这样系统就知道你的APP能处理什么类型的文件了, 别的APP分享的时候,才可以把你的app放在列表里. 如果没有私有的格式,就直接在Document Type里定义就好了 #swift #ios
<font size="1">2022-04-25 18:01 PM</font>
<hr>

Swift 中的 #function 到底是什么？ #swift
<font size="1">2022-04-24 11:31 AM</font>
<hr>

使用 async 修饰的函数与普通的同步函数不同，它被称作异步函数。异步函数可以调用其他异步函数，而同步函数则不能调用异步函数 #swift
<font size="1">2022-04-24 11:14 AM</font>
<hr>

从任务的承载上来讲，线程比协程更重；从调度执行的能力来讲，线程是由操作系统调度的，而协程则是由编程语言的运行时调度的。所以绝大多数的编程语言当中实现的协程都具备更加轻量和更加灵活的特点。对于高负载的服务端，协程的轻量型就表现地很突出；而对于复杂的业务逻辑，特别是与外部异步交互的场景，协程的灵活性就可以发挥作用。#swift
<font size="1">2022-04-24 11:12 AM</font>
<hr>

我们现在提到线程，基本上指的就是操作系统的内核线程；而提到协程，绝大多数都是编程语言层面实现的任务载体 —— 我们看待一个线程，就好像一艘轮船一样，而协程似乎就是装在上面的一个集装箱 #swift
<font size="1">2022-04-24 11:11 AM</font>
Framework 编程指南文档笔记  <https://www.zhaojianfei.com/archives/713>
<font size="1">2022-04-28 22:16 PM</font>
<hr>

关于 bundle 的显示名
显示名使用户可以控制Finder在Finder中的显示方式，而不会破坏依赖它们的客户端。尽管用户可以自由重命名文件，但重命名应用程序或框架可能会导致相关代码模块按名称引用应用程序或框架。因此，当用户更改一个包的名称时，这种改变只是表面的。 Finder不是在文件系统中更改包名称，而是将一个单独的字符串（称为显示名）与该包相关联，然后显示该字符串。 #bundle
<font size="1">2022-04-28 22:05 PM</font>
<hr>




道   可道,非   常道, 名  可名, 非  常名
<font size="1">2022-04-26 00:19 AM</font>
<hr>

python运行在iOS 上 <https://github.com/beeware/Python-Apple-support>
<font size="1">2022-04-25 21:50 PM</font>
<hr>

下载ipa Configurator
<font size="1">2022-04-25 21:19 PM</font>
<hr>

下载ipa文件 Configurator
<font size="1">2022-04-25 21:18 PM</font>
<hr>

非常好的配乐网站,质量高 <https://open.sampld.app/>
<font size="1">2022-04-23 23:44 PM</font>
<hr>

非常好的配乐网站,质量高 <https://open.sampld.app/>
<font size="1">2022-04-23 23:43 PM</font>
<hr>

<https://github.com/zxysilent/fish>
<font size="1">2022-04-22 11:40 AM</font>
<hr>

#terminal prompts disabled  直接用密钥来替代 用户名密码验证

git config --global --add url."git@github.com:".insteadOf "<https://github.com/>"
<font size="1">2022-04-22 10:32 AM</font>
<hr>

苹果APP后台的testflight总提示测试信息不完整,需要把 "需要登录"也点一下,再取消,即使你的APP不需要登录. #ios
<font size="1">2022-04-21 16:25 PM</font>
<hr>

git rm --cached 这里的cached指的是index暂存区,也叫stage区 #git
<font size="1">2022-04-20 13:54 PM</font>
<hr>

spleeter 与 demucs 生成的品质对比, 无人声伴奏demucs占优, 无bass与无鼓声伴奏听感区别不大,原因应该是有人声,且低音人耳朵识别度较低,但单独的人声,bass,drum都是demucs占优,特别是bass,demucs的bass有音头和质感,而spleeter要差很多.但spleeter有5stem有钢琴,这个demucs没有  #demucs #spleeter
<font size="1">2022-04-19 15:46 PM</font>
<hr>

无主引用 unowned 对于初始化赋值之后引用再也不会赋值为nil的实例，使用无主引用；
无主引用默认始终有值；所以只能定义为非可选值类型；在属性、变量前添加unowned关键字，可以声明一个无主引用；
非可选类型变量不能赋值为nil，因此当实例被销毁的时候，ARC无法将引用赋值为nil；
当实例被销毁时，视图访问实例的无主引用会触发运行时错误；因此使用无主引用时请确保引用始终指向一个未销毁的实例 #swift
<font size="1">2022-04-18 00:39 AM</font>
<hr>

func wishHappyBirthday(to celebrator: Named & Aged) { #swift
<font size="1">2022-04-18 00:26 AM</font>
<hr>

static 与 class 的区别
static 可以在类、结构体、或者枚举中使用。而 class 只能在类中使用。
static 可以修饰存储属性，static 修饰的存储属性称为静态变量(常量)。而 class 不能修饰存储属性。
static 修饰的计算属性不能被重写。而 class 修饰的可以被重写。
static 修饰的静态方法不能被重写。而 class 修饰的类方法可以被重写。
class 修饰的计算属性被重写时，可以使用 static 让其变为静态属性。
class 修饰的类方法被重写时，可以使用 static 让方法变为静态方法。

#swift
<font size="1">2022-04-17 12:12 PM</font>
<hr>

由于 final 的类不会有子类，如果协议初始化器实现的类使用了 final 标记，你就不需要使用 required 来修饰了。因为这样的类不能被继承子类。 #swift
<font size="1">2022-04-17 09:15 AM</font>
<hr>

class SomeClass: SomeProtocol {
    required init(someParameter: Int) {
        // initializer implementation goes here
    }
}  required关键字 #swift
<font size="1">2022-04-17 09:14 AM</font>
<hr>

有时一个方法需要改变（或异变）其所属的实例。例如值类型的实例方法（即结构体或枚举），在方法的 func 关键字之前使用 mutating 关键字，来表示在该方法可以改变其所属的实例，以及该实例的所有属性。#swift
<font size="1">2022-04-17 09:06 AM</font>
<hr>

swift中static与class的区别

1.static能修饰class/struct/enum的计算属性、存储属性、类型方法;class能修饰类的计算属性和类方法
  简单一句话: class不能修饰类的存储属性，static可以修饰类的存储属性
2.static修饰的类方法不能继承；class修饰的类方法可以继承
3.在protocol中要使用static

#swift
<font size="1">2022-04-17 09:05 AM</font>
<hr>

扩展和 Objective-C 中的分类类似。（与 Objective-C 的分类不同的是，Swift 的扩展没有名字 #swift
<font size="1">2022-04-17 00:05 AM</font>
<hr>

一、串行调用 
let firstPhoto = await downloadPhoto(named: photoNames[0])
let secondPhoto = await downloadPhoto(named: photoNames[1])
let thirdPhoto = await downloadPhoto(named: photoNames[2])

let photos = [firstPhoto, secondPhoto, thirdPhoto]
show(photos)

二、并行调用
async let firstPhoto = downloadPhoto(named: photoNames[0])
async let secondPhoto = downloadPhoto(named: photoNames[1])
async let thirdPhoto = downloadPhoto(named: photoNames[2])

let photos = await [firstPhoto, secondPhoto, thirdPhoto]
show(photos)

#swift
<font size="1">2022-04-16 23:46 PM</font>
<hr>

await  fn 应该这样理解,  fn是个异步函数,执行时fn会在另外线程或进程执行,执行时当前线程挂起, 挂 点就是await来标记的, fn执行完就会到刚刚的挂 起点,恢复执行 #swift
<font size="1">2022-04-16 23:41 PM</font>
<hr>

defer swift也有defer #swift
<font size="1">2022-04-16 23:32 PM</font>
<hr>

try! 感叹号 取消错误传递 #swift
<font size="1">2022-04-16 23:32 PM</font>
<hr>

取消错误传递
事实上有时你已经知道一个抛出错误或者方法不会在运行时抛出错误。在这种情况下，你可以在表达式前写 try!来取消错误传递并且把调用放进不会有错误抛出的运行时断言当中。如果错误真的抛出了，你会得到一个运行时错误。

比如说，下面的代码使用了 loadImage(_:)函数，它在给定路径下加载图像资源，如果图像不能被加载则抛出一个错误。在这种情况下，由于图像跟着应用走，运行时不会有错误抛出，所以取消错误传递是合适的。

let photo = try! loadImage("./Resources/John Appleseed.jpg")
#swift
<font size="1">2022-04-16 23:31 PM</font>
<hr>

#swift
<font size="1">2022-04-16 23:30 PM</font>
<hr>

Swift 中的错误处理， try, catch  和 throw 的使用与其他语言中的异常处理很相仿。不同于许多语言中的异常处理——包括 Objective-C ——Swift 中的错误处理并不涉及调用堆栈展开，一个高占用过程。因此， throw 语句的性能特征与 return 比不差多少。#swift
<font size="1">2022-04-16 23:26 PM</font>
<hr>

每个类当中只能有一个反初始化器。反初始化器不接收任何形式参数，并且不需要写圆括号：

deinit {
    // perform the deinitialization
}
1
2
3
deinit {
    // perform the deinitialization
}
#swift
<font size="1">2022-04-16 22:59 PM</font>
<hr>

swift中，同一个类的不同init方法是不能直接使用self.init()平行调用的。
必须用关键字convenience修饰的init方法后,才可以使用 self.init(…)
convenience修饰的init方法就叫便捷初始化器.#swift
<font size="1">2022-04-16 22:57 PM</font>
<hr>

如果结构体类型中没有定义任何自定义初始化器，它会自动获得一个成员初始化器。不同于默认初始化器，结构体会接收成员初始化器即使它的存储属性没有默认值。 #swift
<font size="1">2022-04-16 22:13 PM</font>
<hr>

不同于 Objective-C 的初始化器，Swift 初始化器不返回值。这些初始化器主要的角色就是确保在第一次使用之前某类型的新实例能够正确初始化。 #swift
<font size="1">2022-04-16 20:45 PM</font>
<hr>

在异变方法里指定自身 struct Point {
    var x = 0.0, y = 0.0
    mutating func moveBy(x deltaX: Double, y deltaY: Double) {
        self = Point(x: x + deltaX, y: y + deltaY)
    }
} struct Point {
    var x = 0.0, y = 0.0
    mutating func moveBy(x deltaX: Double, y deltaY: Double) {
        self = Point(x: x + deltaX, y: y + deltaY)
    }
} #swift
<font size="1">2022-04-15 16:17 PM</font>
<hr>

willSet didSet 对于属性设置的调试很有帮助. #swift
<font size="1">2022-04-15 09:29 AM</font>
@autocloure 自动闭包,是为了让函数参数中接收闭包不用写{},可读性更强 #swift
<font size="1">2022-04-14 23:17 PM</font>
<hr>

如果一个函数的某个参数被指定为 @escaping 的 closure，那这个 closure 中不能隐式引入 self。目的和前面提到的一样，访问成员变量本质都是通过 self 访问的，省略 self 给人一种能直接访问成员变量的感觉，显式 self 访问确保写代码的人明确这一点，从而在需要的时候通过一些办法来避免 strong reference cycle。#swift
<font size="1">2022-04-14 23:11 PM</font>
<hr>

如果一个闭包被作为一个参数传递给一个函数，并且在函数return之后才被唤起执行，那么这个闭包是逃逸闭包。#swift
<font size="1">2022-04-14 22:55 PM</font>
<hr>

@escaping 逃逸闭包 #swift
<font size="1">2022-04-14 17:29 PM</font>
<hr>


swift闭包表达式的几种写法

1.完整写法

reversedNames = names.sorted(by: { (s1: String, s2: String) -> Bool in
    return s1 > s2
})

2.单行
reversedNames = names.sorted(by: { (s1: String, s2: String) -> Bool in return s1 > s2 } )

3.从语境中推断类型
reversedNames = names.sorted(by: { s1, s2 in return s1 > s2 } )

4.从单表达式闭包隐式返回 
reversedNames = names.sorted(by: { s1, s2 in s1 > s2 } )

5.简写的实际参数名
reversedNames = names.sorted(by: { $0 > $1 } )

6.实际上还有一种更简短的方式来撰写上述闭包表达式。Swift 的 String 类型定义了关于大于号（ >）的特定字符串实现，让其作为一个有两个 String 类型形式参数的函数并返回一个 Bool 类型的值。这正好与  sorted(by:) 方法的第二个形式参数需要的函数相匹配。因此，你能简单地传递一个大于号，并且 Swift 将推断你想使用大于号特殊字符串函数实现：
reversedNames = names.sorted(by: >)

#swift
<font size="1">2022-04-14 11:35 AM</font>
<hr>

闭包表达式语法 { (parameters) -> (return type) in
    statements
  } #swift
<font size="1">2022-04-14 11:28 AM</font>
<hr>

全局函数是一个有名字但不会捕获任何值的闭包；
内嵌函数是一个有名字且能从其上层函数捕获值的闭包；
闭包表达式是一个轻量级语法所写的可以捕获其上下文中常量或变量值的没有名字的闭包。 #swift
<font size="1">2022-04-14 11:18 AM</font>
<hr>

func swapTwoInts(_ a: inout Int, _ b: inout Int)   调用的时候 swapTwoints(&a,&b) #swift
<font size="1">2022-04-14 11:16 AM</font>
<hr>

可变形式参数可以接受零或者多个特定类型的值。当调用函数的时候你可以利用可变形式参数来声明形式参数可以被传入值的数量是可变的。可以通过在形式参数的类型名称后边插入三个点符号（ ...）来书写可变形式参数 #swift
<font size="1">2022-04-14 11:05 AM</font>
每一个 String值都有相关的索引类型， String.Index，它相当于每个 Character在字符串中的位置 #swift
<font size="1">2022-04-13 22:58 PM</font>
<hr>

字符串插值是一种从混合常量、变量、字面量和表达式的字符串字面量构造新 String值的方法 ,swift里用\(), ruby里用 ``  #swift
<font size="1">2022-04-13 22:57 PM</font>
<hr>

Swift 的 String类型是一种值类型 #swift
<font size="1">2022-04-13 22:55 PM</font>
<hr>

取消字符串中的转义  #"hello\nworld"#, 多个#也是可以的 ##"hello\nworld"## #swift
<font size="1">2022-04-13 22:52 PM</font>
<hr>

swift 多行字符串字面量跟python有点像  """ """ #swift
<font size="1">2022-04-13 22:48 PM</font>
<hr>

swift 区间运算符有点意思  a...b  ,指的是a到b包括ab, 注意是3个点, 半开区间运算符 a..<b,不包括b,很形象. 还有单侧区间,  for name in names[2...], for name in names[...2], 半开区间也可以有单侧形式 names[..<2] #swift
<font size="1">2022-04-13 22:46 PM</font>
<hr>

合并空值运算符  a ?? b   等价于  a != nil ? a! :b   如果可选项 a有值则展开,无值则返回默认值 b  #swift
<font size="1">2022-04-13 22:36 PM</font>
<hr>

do{ try fn()} catch{} swift中的异常捕获相对更好些.具体到能看到某个函数会引发异常,而不是像java 都在一个try中 #swift
<font size="1">2022-04-13 22:25 PM</font>
<hr>

do{ try fn()} catch{} swift中的异常捕获相对更好些.具体到能看到某个函数会引发异常,而不是像java 都在一个try中 .
<font size="1">2022-04-13 22:25 PM</font>
<hr>

user?.name  如果user不是nil就获取其name值 , user!.name 强制拆name值,如果nil,引发异常  #swift
<font size="1">2022-04-13 22:23 PM</font>
<hr>

swift中显示可选项 let name: String?  ,取值 的时候要使用 name! ,无值会异常.  隐式可选 项 let name: String! , 取值的时候不用!, 那跟let name: String还有什么区别呢? #swift
<font size="1">2022-04-13 21:59 PM</font>
<hr>

verbatim 一字不差
<font size="1">2022-04-13 17:43 PM</font>
<hr>

Text("hello") 和 var s= "hello"; Text(s)是不一样的 #swiftui
<font size="1">2022-04-13 17:43 PM</font>
<hr>

toast 显示的时间应该跟toast显示的文字的长度正相关  #设计 #swiftui 
<font size="1">2022-04-13 17:34 PM</font>
<hr>

Enable vim mode in Xcode 13 From the global top menu choose Editor > Vim Mode
<font size="1">2022-04-13 11:21 AM</font>

如果在一个 WindowGroup 里加入多个 View, 呈现状态有点类似 VStack。

在一个 Scene 中加入多个 WindowGroup，只有最前面的可以被显示。#swiftui
<font size="1">2022-04-12 23:13 PM</font>
<hr>

为了能够让开发者更好的掌控代码，同时也保持对于上一版本良好的兼容性，苹果在 SwiftUI2.0 中添加了@StateObject。顾名思义，它是@State 的引用类型版本。

在 WWDC 的视频中，苹果明确的表明@StateObject 是被创建他的 View 所持有的，也就是说，实例的生命周期是完全可控的，是同创建它的 View 的生命周期一样的。

@StateObject 和 @ObservedObject 的区别就是实例是否被创建其的 View 所持有，其生命周期是否完全可控。 #swiftui
<font size="1">2022-04-12 22:57 PM</font>
<hr>

@StateObject 和 @ObservedObject 的区别就是实例是否被创建其的 View 所持有，其生命周期是否完全可控 #swiftui
<font size="1">2022-04-12 22:56 PM</font>
<hr>

@State 只能用于当前视图，并且其对应的数据类型为值类型（如果非要对应引用类型的话则必须在每次赋值时重新创建新的实例才可以）#swiftui
<font size="1">2022-04-12 22:27 PM</font>
<hr>

在 SwiftUI 中，视图是由数据（状态）驱动的。按照苹果的说法，视图是状态的函数，而不是事件的序列（The views are a function of state, not a sequence of events）。每当视图在创建或解析时，都会为该视图和与该视图中使用的状态数据之间创建一个依赖关系，每当状态的信息发生变化是，有依赖关系的视图则会马上反应出这些变化并重绘。 #swiftui
<font size="1">2022-04-12 22:26 PM</font>
<hr>

demucs 运行前判断系统cpu多少核心 
<font size="1">2022-04-12 17:46 PM</font>
<hr>

from signalProcessing import get_chroma, \
                         chordgram,\
                         chord_sequence_filter,\
                         chord_sequence,\
                         chord_sequence_with_time  一个和弦识别软件中引用的库,不太准 #和弦识别
<font size="1">2022-04-12 10:31 AM</font>
<hr>

file.io 免费上传下载文件,一次性
<font size="1">2022-04-11 17:16 PM</font>
<hr>

<https://www.jianshu.com/p/c5d0bb6cf0eb>
<font size="1">2022-04-07 14:59 PM</font>
<hr>

PopOver With Arrows Using SwiftUI  #keyword
<font size="1">2022-04-06 20:16 PM</font>
<hr>

下载bilibili视频 <https://github.com/leiurayer/downkyi> 
<font size="1">2022-04-05 20:18 PM</font>
<hr>

Half Sheet Modal #swiftui #keyword
<font size="1">2022-04-02 16:08 PM</font>
<hr>

swiftUI 中的环境变量 首先需要声明,并且需要有一个入口注入.这个入口一般是view注入后,入口后面的view都将共享这个环境变量.如果是在App使用,要手动声明这个变量对象,APP入口文件使用这个对象变量,同时其他view需要使用,也需要将这个变量注入到你想要的入口view中.在view中需要做变量声明 #swiftui
<font size="1">2022-04-02 10:51 AM</font>
<hr>

test
<font size="1">2022-04-01 17:00 PM</font>
<hr>

在 SwiftUI 中，修饰符的功能类似于 CSS，用来在应用布局中定位和配置视图，如修改视图的大小、背景、添加动画、添加手势等等。View 协议通过扩展提供了大量的修饰符，它们以协议方法的形式给出，同时提供了默认实现。

修饰符的效果具有传递性，也就是说，父视图上使用的修饰符也会影响到其所有子视图，除非子视图显式的调用修饰符来覆盖这种效果。

之所以能以链式的方式调用修饰符，是因为每个修饰符方法的返回值是 some View （如frame() 的声明），仍然是一个视图，所以可以在新的视图的基础上继续调用修饰符。

需要注意的是，在链式调用的过程中，修饰符的顺序会对实际效果产生影响。相同的两个修饰符以不同的顺序调用，呈现的结果可能是不一样的。 #swiftui
<font size="1">2022-04-01 16:59 PM</font>
<hr>

每一个单独的 Modifier 并不会对 View 类型实例进行操作，而是一个返回 some View类型的闭包。因此 Modifier 的运行机制与我们熟悉的 UIKit 中对视图属性进行修改的方式是相反的，我们构建出一个视图时并不会先初始化出一个 View 实例再对其进行修饰，而是通过声明的各种Modifier 构建出View 实例
<font size="1">2022-04-01 16:52 PM</font>
<hr>

ffplay 播放中实时改变参数可以等价于新的参数从当前位置播放 #ffmpeg
<font size="1">2022-03-30 11:19 AM</font>
<hr>

oc中 block闭包默认对外面变量访问是变量的副本,如果需要修改外部变量,则需要在外部变量前加 __block,相当于block访问此变量的指针,因此可以改变变量,而不是默认的副本  #objc
<font size="1">2022-03-29 10:08 AM</font>
<hr>

aka是also known as缩写，指的是亦称、也被称为的意思
<font size="1">2022-03-29 09:46 AM</font>
<hr>

大七和弦和半减七, 大七根音升音音就是升的这个半音的半减七,因为大七升根相当于 357降了半音,正好是b3b5b7.  反之,半减七根音降半音相当于降的这个音的大七,因为b3 b5 b7升半音 357就是大七了. 这个在吉他上更明显一些 #弹琴
<font size="1">2022-03-26 07:51 AM</font>
<hr>

ffplay -af "volume=1.0,atempo=4.0" 1.mp3
<font size="1">2022-03-24 22:33 PM</font>
<hr>

转调分转调和变速两部分,先转调后转速质量好,反之则会丢失细节
<font size="1">2022-03-22 16:38 PM</font>
<hr>

ffmpeg ff是Fast Forward ,mpeg是Moving Picture Experts Group的缩写.(动态图像专家组)
<font size="1">2022-03-22 14:36 PM</font>
<hr>

未签名的macOS app启动时候会显示警告,这个警告可以通过安全中心打开后不再提示,如何让其再提示呢?  #问题
<font size="1">2022-03-22 14:00 PM</font>
<hr>

存储不压缩(-j参数不创建外层文件夹)  zip -0 -r -j  xxx.zip xxx
<font size="1">2022-03-21 14:14 PM</font>
<hr>

创建分卷压缩文件 zip -s 100m -r file.zip foo/
<font size="1">2022-03-21 13:51 PM</font>
<hr>

<https://api.iyk0.com/> 免费api
<font size="1">2022-03-21 10:50 AM</font>
<hr>

ffmpeg 取消控制台输出 后面加上 -loglevel quiet
<font size="1">2022-03-11 10:15 AM</font>
<hr>

终端代理设置一般使用 ALL_PROXY,但有时候也需要设置 https_proxy 
<font size="1">2022-03-10 15:56 PM</font>
<hr>


独立运行的python构建版本,最小化运行时依赖,<https://python-build-standalone.readthedocs.io/en/latest/>  #python #pyoxidizer
<font size="1">2022-03-10 14:33 PM</font>

mkv播放器可以选择首选音频语言
<font size="1">2022-03-09 21:56 PM</font>
<hr>

PyOxidizer python自包含打包应用
<font size="1">2022-03-09 17:51 PM</font>
<hr>

python自包含环境,绿色运行环境,可以独立运行python的绿色运行环境 Self-contained Python environment for Mac OS #python #standalone #关键字
<font size="1">2022-03-09 17:01 PM</font>
<hr>

python自包含环境,绿色运行环境,可以独立运行python的绿色运行环境 Self-contained Python environment for Mac OS #python #standalone
<font size="1">2022-03-09 17:00 PM</font>
<hr>

platypus 把python程序包装成独立的mac APP 
<font size="1">2022-03-09 16:39 PM</font>
<hr>

ffmpeg静态版 <https://evermeet.cx/pub/ffmpeg/>
<font size="1">2022-03-09 13:40 PM</font>
<hr>

找免费商业因音乐可以搜“creative commons music free”或“creative commons”查找支持知识共享的歌曲，进入歌曲详情查看具体的许可协议
<font size="1">2022-03-07 14:06 PM</font>
<hr>

ffmpeg -af 与complex-filter不可以同时使用
<font size="1">2022-03-07 10:49 AM</font>

ffmpeg中setTempo setRate setPitch的区别是什么 #ffmpeg
<font size="1">2022-03-05 20:40 PM</font>

<hr>

<https://tailwindcss.com/> 让不是很懂CSS的人能写出不那么丑的前端界面
<font size="1">2022-03-01 17:58 PM</font>
<hr>

<https://tailwindcss.com/>
<font size="1">2022-03-01 17:57 PM</font>
<hr>

B6 就是一个三和弦加了一个6音  #弹琴
<font size="1">2022-03-01 17:51 PM</font>
<hr>

属七和弦的变化引申音, b9 #9  #11 b13.  9可升降, 11只可升,因为降的话就是3了. 13只可降,因为升的话就是b7了,是和弦内音.  记忆的话就是降9是小2度,升9是小3度, 升11是增4度,降13就是小6度   #弹琴
<font size="1">2022-03-01 15:11 PM</font>
<hr>

属七和弦的变化引申音, b9 #9  #11 b13.  9可升降, 11只可升,因为降的话就是3了. 13只可降,因为升的话就是b7了,是和弦内音  #弹琴
<font size="1">2022-03-01 15:09 PM</font>
<hr>

大、小、属的引申音不受和弦性质影响,都一样 ,以根音为参照物,大二度是9,纯4度是11,大6度是13  #弹琴
<font size="1">2022-03-01 15:02 PM</font>
<hr>

demucs 3.0.4增加伴奏轨输出 
<font size="1">2022-03-01 14:48 PM</font>
<hr>

alt音阶是旋律小调的第七级音阶，所以，将alt音阶与旋律小调音阶结合起来记忆就方便多啦！ 从C旋律小调的第七级开始，即为B alt音阶 ，我们可以用在B alt 和弦上面！其他调的alt音阶，我们都可以从这个调主音上方小二度的旋律小调音阶推导出来！ #弹琴
<font size="1">2022-02-28 16:45 PM</font>
<hr>

键盘中音阶手指的分配 ,五声音阶一般就是3+2或是2+3, blues音阶(6个音),一般就是4+2或者3+3  #弹琴
<font size="1">2022-02-28 16:17 PM</font>
<hr>

两个系统,一个是看到一个和弦,有几种调式音阶可用 ,另一个是这个和弦是几级,确定用什么什么调的调式音阶  #弹琴
<font size="1">2022-02-28 16:15 PM</font>
<hr>

学习音乐过程中,听话比听懂话更重要
<font size="1">2022-02-28 16:13 PM</font>
<hr>

Blues大小调说法的由来

1	b3	4	b5	5	b7

6	1	2	b3	3	5

  1	2	b3	3	5	6	

#弹琴
<font size="1">2022-02-28 14:32 PM</font>
<hr>

blues12小节 1411-4411-5411, 后面都是411,小节前面分别是145 #弹琴
<font size="1">2022-02-28 14:16 PM</font>

roland td25 电鼓驱安装注意几点. 一是要在电鼓上设置驱动类型为 vendor,并且要重启电鼓,二是安装完驱动前不要连接电鼓,驱动安装后重启的时候要连接电鼓  #问题解决
<font size="1">2022-02-27 08:37 AM</font>

<hr>

DT770 Pro 250oml
<font size="1">2022-02-24 17:44 PM</font>
<hr>

先找到一个曲子里所有的属. 这些属极有可能就是251中的5  #弹琴
<font size="1">2022-02-23 11:37 AM</font>
<hr>

251,大调是 小、属、大, 小调是半减属小 #弹琴
<font size="1">2022-02-23 10:17 AM</font>
<hr>

键盘上7和弦第三转位要理解在三和弦在左边加一个7音 #弹琴
<font size="1">2022-02-22 21:56 PM</font>
<hr>

Toontrack EZmix 
<font size="1">2022-02-22 14:28 PM</font>
<hr>

spleeter或是demucs 分出来的 bass,drum,vocal 非常适合在live里进行midi转换 #弹琴
<font size="1">2022-02-22 10:11 AM</font>
<hr>

airpods 为啥连不上小米盒子?
<font size="1">2022-02-21 17:11 PM</font>
<hr>

sidechain ,根据一个(轨道)声音调整另外一个(轨道)声音 
<font size="1">2022-02-18 16:06 PM</font>
<hr>

很多时候其实一个人缺乏的是：在做事之前就能判断出这事能做大，还是不能做大
<font size="1">2022-02-18 13:32 PM</font>
<hr>

小米空气净化器上放macbook,当个超级静音散热风扇,电脑唤醒、待机是否可以触发散热风扇关闭开启?   #idea
<font size="1">2022-02-18 03:35 AM</font>
<hr>

调式音阶,比如Dorian是不是也可以就理解为  2 3 4 5 6 7 1, 而不一定要理解为 1 2 b3 4 5 6 b7,  这样在吉他上找音是不是会更容易? 以2为开始是不是应该人听觉上也不会以为1才是主音.  这个所谓的主音,到底 是听觉上的,还是符号层面的? #弹琴
<font size="1">2022-02-16 17:36 PM</font>
<hr>

即兴的两大思路.   一是以调为中心,也可以说是以音阶为中心,和弦为音阶服务. 另外一种思路是以和弦为中心, 针对某个和弦,可以跑不同调式的音阶(从调性上可能是不用调)  #弹琴
<font size="1">2022-02-16 09:43 AM</font>
<hr>

尸位素餐
/shīwèi-sùcān/
空占着职位，白吃饭不做事。
<font size="1">2022-02-16 09:04 AM</font>
<hr>

android电视盒子上的 KODI播放器功能非常强大, 播放MKV的时候可以指定默认语言的字幕和音频. 
<font size="1">2022-02-16 08:57 AM</font>
<hr>

每个调式音阶对应一类和弦, 这个跟大调和弦级数还有点对应关系, 1 4级是大七, 236级是小七,5级是属七. 7级是半减七.  调式音阶本来就是从大调音阶推导出来的. #弹琴 
<font size="1">2022-02-15 16:40 PM</font>
<hr>

每一个调式音阶对应一个和弦,主要看音阶中的3音和7音. 比如 Dorian. 1 2 b3 4 5 6 b7,对应的就是小七和弦, 像Lydian 1 2 3 #4 5 6 7 ,对应的就是大七和弦,其中#4并不需要理会. Mixolydian 1 2 3 4 5 6 b7,对应的是属七和弦. Locian 1 b2 b3 4 b5 b6 b7 这个肯定就是半减七和弦了. 所以看到一个大七和弦,可以弹 Ionian和Lydian, 小七可以弹Dorian,Phrygian  #弹琴
<font size="1">2022-02-15 16:37 PM</font>
<hr>

大小调思维中,音阶是老大,和弦跟着音阶走.调式思维中,和弦是老大,音阶是围绕着和弦来的 #弹琴
<font size="1">2022-02-15 16:00 PM</font>
<hr>

根音和五音是纯五度,五音可省略  #弹琴
<font size="1">2022-02-15 14:43 PM</font>
<hr>

三位音乐制作 人: 1.富田惠一 2.吴庆隆 3. 钟兴民
<font size="1">2022-02-15 10:31 AM</font>
<hr>

在1w左右预算你还能选择一个神级MIDI键盘，就是Doepher。这个深受好莱坞制作人青睐的牌子，自带锤感反馈系统，完全真实钢琴配种，可以选择带手提箱和不带手提箱的版本，不带手提箱的话，你就得自己组装了
<font size="1">2022-02-14 17:38 PM</font>
<hr>

豆瓣top250 和IMDB top250 里相同的电影有82部
<font size="1">2022-02-14 15:07 PM</font>
<hr>

对不起领导的忽悠
<font size="1">2022-02-14 11:45 AM</font>
<hr>

推荐 svelte+fastapi
<font size="1">2022-02-14 09:57 AM</font>
<hr>

degit做的事很简单，复制git仓库代码
<font size="1">2022-02-14 09:54 AM</font>
<hr>

进步与兴趣钟摆的中间点需要人主动发力推一把
<font size="1">2022-02-11 10:05 AM</font>
<hr>

米果,把加湿器打开
不要,我要加干
那不叫加干,叫除湿
'厨师',厨师是做菜的
@!@!?
#米果

<font size="1">2022-02-11 08:52 AM</font>
<hr>

音频跳线盒
<font size="1">2022-02-10 15:17 PM</font>
<hr>

react.js 之于next.js 和  vue.js之于nuxt.js   前者next.js中的e是react第二个字母,nuxt中的的u是vue中的第二个字母
<font size="1">2022-02-08 10:27 AM</font>

<hr>

专门生成静态网站(SSG)
<font size="1">2022-02-08 10:25 AM</font>
<hr>

Server-Side Rendering (SSR) Vs Client-Side Rendering (CSR)
<font size="1">2022-02-08 10:02 AM</font>
<hr>

饕餮 /Tāotiè/大餐
<font size="1">2022-02-08 09:04 AM</font>
<hr>

一个人推的最新文件名固定在年底的时候会因为同步造成上一年的内容也新一年的内容合并,解决办法第一年使用不同文件名 
<font size="1">2022-02-07 09:29 AM</font>
<hr>

mac上鼠标在窗口的位置,即使窗口不是焦点,也可以接收scroll消息, 而sharemouse,可以以屏幕为单位,接收消息. 
<font size="1">2022-02-06 22:03 PM</font>
<hr>

hibernatemode=0, macmini,iMac台式机默认参数,数据保留在内存, hibernatemode=3 macbook默认参数,数据保留在内存和硬盘 
<font size="1">2022-02-05 06:59 AM</font>
<hr>

一套键盘鼠标控制多台电脑软件 sharemouse
<font size="1">2022-02-02 17:49 PM</font>
<hr>

VEP  主从系统的关键软件：Vienna Ensemble Pro 6+一个加密狗 
<font size="1">2022-02-01 00:27 AM</font>
<hr>

komplete kontrol 预览音色音量在左下角 #ni
<font size="1">2022-02-01 00:16 AM</font>
<hr>


ln 目录时, 转义和双引号只用其一
<font size="1">2021-12-04 19:59 PM</font>
<hr>


md编辑器,还有Zettlr 和 Mark Text
<font size="1">2021-11-28 22:08 PM</font>
<hr>


和声分析工具 <https://xclient.info/> <https://xclient.info/>
<font size="1">2021-11-13 22:32 PM</font>

-运动健康记录管理
连接手环设备可查看用户步数和心率数据，给你多一份关爱。
<font size="1">2021-12-03 13:23 PM</font>

你不慌张了,青春就没了 --高晓松
<font size="1">2022-01-29 16:55 PM</font>
<hr>

前端的问题不是难，而是它面对最终用户。只要用户的喜好和口味发生变化，前端就必须跟上
<font size="1">2022-01-29 15:05 PM</font>
<hr>

音乐app应该增加个功能,点喜欢同时下载这首歌. #idea
<font size="1">2022-01-29 14:47 PM</font>
<hr>

Github Pages的server应该是跑在UTC时区下的，而 我所在的时区是北京时区，也就是UTC+8。在我今天发布的这篇博客里，所有的时间用的都是 UTC+8时区的本地时间。Github Pages估计只会编译server的当前时刻之前的文件. 解决办法就是将时间设置成前一天,gitpage就可以更新了 #gitpage
<font size="1">2022-01-29 14:29 PM</font>
<hr>

同样是清粥小菜, 饿的时候便会不同,天天鱼肉亦会不同
<font size="1">2022-01-26 17:37 PM</font>
<hr>

了不起的javascript读书笔记  <https://github.com/anbang/javascript-notes>  #书 
<font size="1">2022-01-26 13:30 PM</font>
<hr>

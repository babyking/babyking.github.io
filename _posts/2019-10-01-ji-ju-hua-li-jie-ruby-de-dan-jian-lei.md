---
typora-root-url: ../
typora-copy-images-to: ../image
layout: post
title: 几句话理解ruby的单件类
date: 2019-10-01 22:30
category: 技术
tags: [ruby]
---



ruby的单件类的理解有点像"从前有座山,山里有个庙".



1. 方法是定义在类中的.

2. 类,类的实例对象,就叫做普通对象,一般叫做实例[对象]. 

   在类中定义的方法,新建的**所有的**类实例中就可以调用这个方法.

3. 如果一个类的实例对象想要增加自己的方法,且不影响其他实例对象,就需要定义这个对象的单件方法,这个方法定义的地方就是这个对象的单件类. 每个对象(广义的对象)都有单件类

   ```ruby
   class D
   end
   a=D.new
   b=D.new
   class << a
     def hello
       puts 'hello'
     end
   end
   a.hello # => "hello"
   b.hello # Error
   ```

4. 类也是一个对象,遵循上面的1,2,3.

   ```ruby
   class D
     def self.hello
       puts 'hello'
     end
   end
   
   #也可以使用下面的写法.
   class D
     class << self  #这里的self就是D本身
       def hello
         puts 'hello'
       end
     end
   end
   
   
   D.hello # => "hello"  这里的D是一个对象,
   
   ```

   

总结下来两点

1. 一个对象,无论是普通对象还是类对象,如果要定义一个只属于对象自己使用的方法,那就只能在`单件类`中定义,这样的方法,在普通的类中就叫做`类方法` 在普通的对象中就叫就`单件类实例方法` (自己造出来的词)

   > 普通对象的单件类实例方法是java中没有的概念,实际意义
   >
   > 类方法在普通的使用层面跟java定义类似,但在`类也是对象,也遵循普通对象所有的行为`这个层面来看,又是特别的存在

2. 一个对象的父类的单件类就是这个对象的单件类的父类

   >这里的父类,单件类的理解的重点就是在当前上下文里,是把对象当作是`类`还 `对象` ,ruby这么设计的目的就是让`对象`可以访问`类方法`



后记:

ruby的类系统设计在理解上更有点哲学意味,而java的设计更像是实用主义,定义简单明确,也易于理解.

回头再想一下,ruby的设计更像是公理和其推导.

先有公理:

> **所有的一切都是对象,对象如果需要定义其自身方法,需要在其单件类中定义**

接着再另一个层面对这些对象进行划分, 有的是类(对象),有的是类new出来的普通对象.这些类和对象的关系就跟java世界的逻辑定义基本一至,也符合人的直觉理解.  

但更重要的是它要符合公理1.



大家都是对象,在对象行为方面是一致的.

但当你要扮演的是`孵化`角色的`类`时,定义的方法就是会对类new出来的实例对象共享.

```ruby
class D
  def hello
  end
end
```



 如果你同时又要扮演一个独立的对象时,你要定义一个自己使用的方法,那就需要你在这个对象(其实也是类)的单件类中定义方法

```ruby
class D
  def  self.hello
  end
end
```

当然,单件类也是一个对象,这个对象也可以有自己的单件类.定义上是可以无限延展的,但实际应用中可能不需要这么多,只是在定义上是自洽的,是符合`美`的标准的.



其实只需要记一点,就是作为一个对象,要定义只属于自己的方法就就在单件类中去实现.没了



几句好像说不清楚这个事情.
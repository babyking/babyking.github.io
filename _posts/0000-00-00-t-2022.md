---
typora-root-url: ../
typora-copy-images-to: ../image
layout: page 
title: "一个人推"
permalink: /t/2022/
date: 2022-01-01 00:00
---

test 
<font size="1">2022-04-26 00:51 AM</font>
<hr>

flomo 的alfred 插件用的是python2,在macOS 12.3下不工作了,因为12.3 移除了python2 
<font size="1">2022-04-26 00:45 AM</font>
<hr>

道   可道,非   常道, 名  可名, 非  常名
<font size="1">2022-04-26 00:35 AM</font>
<hr>

道   可道,非   常道, 名  可名, 非  常名
<font size="1">2022-04-26 00:19 AM</font>
<hr>

python运行在iOS 上 <https://github.com/beeware/Python-Apple-support>
<font size="1">2022-04-25 21:50 PM</font>
<hr>

下载ipa Configurator
<font size="1">2022-04-25 21:19 PM</font>
<hr>

下载ipa文件 Configurator
<font size="1">2022-04-25 21:18 PM</font>
<hr>

非常好的配乐网站,质量高 <https://open.sampld.app/>
<font size="1">2022-04-23 23:44 PM</font>
<hr>

非常好的配乐网站,质量高 <https://open.sampld.app/>
<font size="1">2022-04-23 23:43 PM</font>
<hr>

<https://github.com/zxysilent/fish>
<font size="1">2022-04-22 11:40 AM</font>
<hr>

#terminal prompts disabled  直接用密钥来替代 用户名密码验证

git config --global --add url."git@github.com:".insteadOf "<https://github.com/>"
<font size="1">2022-04-22 10:32 AM</font>
<hr>

苹果APP后台的testflight总提示测试信息不完整,需要把 "需要登录"也点一下,再取消,即使你的APP不需要登录. #ios
<font size="1">2022-04-21 16:25 PM</font>
<hr>

git rm --cached 这里的cached指的是index暂存区,也叫stage区 #git
<font size="1">2022-04-20 13:54 PM</font>
<hr>

spleeter 与 demucs 生成的品质对比, 无人声伴奏demucs占优, 无bass与无鼓声伴奏听感区别不大,原因应该是有人声,且低音人耳朵识别度较低,但单独的人声,bass,drum都是demucs占优,特别是bass,demucs的bass有音头和质感,而spleeter要差很多.但spleeter有5stem有钢琴,这个demucs没有  #demucs #spleeter
<font size="1">2022-04-19 15:46 PM</font>
<hr>

无主引用 unowned 对于初始化赋值之后引用再也不会赋值为nil的实例，使用无主引用；
无主引用默认始终有值；所以只能定义为非可选值类型；在属性、变量前添加unowned关键字，可以声明一个无主引用；
非可选类型变量不能赋值为nil，因此当实例被销毁的时候，ARC无法将引用赋值为nil；
当实例被销毁时，视图访问实例的无主引用会触发运行时错误；因此使用无主引用时请确保引用始终指向一个未销毁的实例 #swift
<font size="1">2022-04-18 00:39 AM</font>
<hr>

func wishHappyBirthday(to celebrator: Named & Aged) { #swift
<font size="1">2022-04-18 00:26 AM</font>
<hr>

static 与 class 的区别
static 可以在类、结构体、或者枚举中使用。而 class 只能在类中使用。
static 可以修饰存储属性，static 修饰的存储属性称为静态变量(常量)。而 class 不能修饰存储属性。
static 修饰的计算属性不能被重写。而 class 修饰的可以被重写。
static 修饰的静态方法不能被重写。而 class 修饰的类方法可以被重写。
class 修饰的计算属性被重写时，可以使用 static 让其变为静态属性。
class 修饰的类方法被重写时，可以使用 static 让方法变为静态方法。

#swift
<font size="1">2022-04-17 12:12 PM</font>
<hr>

由于 final 的类不会有子类，如果协议初始化器实现的类使用了 final 标记，你就不需要使用 required 来修饰了。因为这样的类不能被继承子类。 #swift
<font size="1">2022-04-17 09:15 AM</font>
<hr>

class SomeClass: SomeProtocol {
    required init(someParameter: Int) {
        // initializer implementation goes here
    }
}  required关键字 #swift
<font size="1">2022-04-17 09:14 AM</font>
<hr>

有时一个方法需要改变（或异变）其所属的实例。例如值类型的实例方法（即结构体或枚举），在方法的 func 关键字之前使用 mutating 关键字，来表示在该方法可以改变其所属的实例，以及该实例的所有属性。#swift
<font size="1">2022-04-17 09:06 AM</font>
<hr>

swift中static与class的区别

1.static能修饰class/struct/enum的计算属性、存储属性、类型方法;class能修饰类的计算属性和类方法
  简单一句话: class不能修饰类的存储属性，static可以修饰类的存储属性
2.static修饰的类方法不能继承；class修饰的类方法可以继承
3.在protocol中要使用static

#swift
<font size="1">2022-04-17 09:05 AM</font>
<hr>

扩展和 Objective-C 中的分类类似。（与 Objective-C 的分类不同的是，Swift 的扩展没有名字 #swift
<font size="1">2022-04-17 00:05 AM</font>
<hr>

一、串行调用 
let firstPhoto = await downloadPhoto(named: photoNames[0])
let secondPhoto = await downloadPhoto(named: photoNames[1])
let thirdPhoto = await downloadPhoto(named: photoNames[2])
 
let photos = [firstPhoto, secondPhoto, thirdPhoto]
show(photos)

二、并行调用
async let firstPhoto = downloadPhoto(named: photoNames[0])
async let secondPhoto = downloadPhoto(named: photoNames[1])
async let thirdPhoto = downloadPhoto(named: photoNames[2])
 
let photos = await [firstPhoto, secondPhoto, thirdPhoto]
show(photos)

#swift
<font size="1">2022-04-16 23:46 PM</font>
<hr>

await  fn 应该这样理解,  fn是个异步函数,执行时fn会在另外线程或进程执行,执行时当前线程挂起, 挂 点就是await来标记的, fn执行完就会到刚刚的挂 起点,恢复执行 #swift
<font size="1">2022-04-16 23:41 PM</font>
<hr>

defer swift也有defer #swift
<font size="1">2022-04-16 23:32 PM</font>
<hr>

try! 感叹号 取消错误传递 #swift
<font size="1">2022-04-16 23:32 PM</font>
<hr>

取消错误传递
事实上有时你已经知道一个抛出错误或者方法不会在运行时抛出错误。在这种情况下，你可以在表达式前写 try!来取消错误传递并且把调用放进不会有错误抛出的运行时断言当中。如果错误真的抛出了，你会得到一个运行时错误。

比如说，下面的代码使用了 loadImage(_:)函数，它在给定路径下加载图像资源，如果图像不能被加载则抛出一个错误。在这种情况下，由于图像跟着应用走，运行时不会有错误抛出，所以取消错误传递是合适的。

let photo = try! loadImage("./Resources/John Appleseed.jpg")
#swift
<font size="1">2022-04-16 23:31 PM</font>
<hr>

#swift
<font size="1">2022-04-16 23:30 PM</font>
<hr>

Swift 中的错误处理， try, catch  和 throw 的使用与其他语言中的异常处理很相仿。不同于许多语言中的异常处理——包括 Objective-C ——Swift 中的错误处理并不涉及调用堆栈展开，一个高占用过程。因此， throw 语句的性能特征与 return 比不差多少。#swift
<font size="1">2022-04-16 23:26 PM</font>
<hr>

每个类当中只能有一个反初始化器。反初始化器不接收任何形式参数，并且不需要写圆括号：

deinit {
    // perform the deinitialization
}
1
2
3
deinit {
    // perform the deinitialization
}
#swift
<font size="1">2022-04-16 22:59 PM</font>
<hr>

swift中，同一个类的不同init方法是不能直接使用self.init()平行调用的。
必须用关键字convenience修饰的init方法后,才可以使用 self.init(…)
convenience修饰的init方法就叫便捷初始化器.#swift
<font size="1">2022-04-16 22:57 PM</font>
<hr>

如果结构体类型中没有定义任何自定义初始化器，它会自动获得一个成员初始化器。不同于默认初始化器，结构体会接收成员初始化器即使它的存储属性没有默认值。 #swift
<font size="1">2022-04-16 22:13 PM</font>
<hr>

不同于 Objective-C 的初始化器，Swift 初始化器不返回值。这些初始化器主要的角色就是确保在第一次使用之前某类型的新实例能够正确初始化。 #swift
<font size="1">2022-04-16 20:45 PM</font>
<hr>

在异变方法里指定自身 struct Point {
    var x = 0.0, y = 0.0
    mutating func moveBy(x deltaX: Double, y deltaY: Double) {
        self = Point(x: x + deltaX, y: y + deltaY)
    }
} struct Point {
    var x = 0.0, y = 0.0
    mutating func moveBy(x deltaX: Double, y deltaY: Double) {
        self = Point(x: x + deltaX, y: y + deltaY)
    }
} #swift
<font size="1">2022-04-15 16:17 PM</font>
<hr>

willSet didSet 对于属性设置的调试很有帮助. #swift
<font size="1">2022-04-15 09:29 AM</font>
@autocloure 自动闭包,是为了让函数参数中接收闭包不用写{},可读性更强 #swift
<font size="1">2022-04-14 23:17 PM</font>
<hr>

如果一个函数的某个参数被指定为 @escaping 的 closure，那这个 closure 中不能隐式引入 self。目的和前面提到的一样，访问成员变量本质都是通过 self 访问的，省略 self 给人一种能直接访问成员变量的感觉，显式 self 访问确保写代码的人明确这一点，从而在需要的时候通过一些办法来避免 strong reference cycle。#swift
<font size="1">2022-04-14 23:11 PM</font>
<hr>

如果一个闭包被作为一个参数传递给一个函数，并且在函数return之后才被唤起执行，那么这个闭包是逃逸闭包。#swift
<font size="1">2022-04-14 22:55 PM</font>
<hr>

@escaping 逃逸闭包 #swift
<font size="1">2022-04-14 17:29 PM</font>
<hr>


swift闭包表达式的几种写法

1.完整写法

reversedNames = names.sorted(by: { (s1: String, s2: String) -> Bool in
    return s1 > s2
})

2.单行
reversedNames = names.sorted(by: { (s1: String, s2: String) -> Bool in return s1 > s2 } )

3.从语境中推断类型
reversedNames = names.sorted(by: { s1, s2 in return s1 > s2 } )

4.从单表达式闭包隐式返回 
reversedNames = names.sorted(by: { s1, s2 in s1 > s2 } )

5.简写的实际参数名
reversedNames = names.sorted(by: { $0 > $1 } )

6.实际上还有一种更简短的方式来撰写上述闭包表达式。Swift 的 String 类型定义了关于大于号（ >）的特定字符串实现，让其作为一个有两个 String 类型形式参数的函数并返回一个 Bool 类型的值。这正好与  sorted(by:) 方法的第二个形式参数需要的函数相匹配。因此，你能简单地传递一个大于号，并且 Swift 将推断你想使用大于号特殊字符串函数实现：
reversedNames = names.sorted(by: >)

#swift
<font size="1">2022-04-14 11:35 AM</font>
<hr>

闭包表达式语法 { (parameters) -> (return type) in
    statements
  } #swift
<font size="1">2022-04-14 11:28 AM</font>
<hr>

全局函数是一个有名字但不会捕获任何值的闭包；
内嵌函数是一个有名字且能从其上层函数捕获值的闭包；
闭包表达式是一个轻量级语法所写的可以捕获其上下文中常量或变量值的没有名字的闭包。 #swift
<font size="1">2022-04-14 11:18 AM</font>
<hr>

func swapTwoInts(_ a: inout Int, _ b: inout Int)   调用的时候 swapTwoints(&a,&b) #swift
<font size="1">2022-04-14 11:16 AM</font>
<hr>

可变形式参数可以接受零或者多个特定类型的值。当调用函数的时候你可以利用可变形式参数来声明形式参数可以被传入值的数量是可变的。可以通过在形式参数的类型名称后边插入三个点符号（ ...）来书写可变形式参数 #swift
<font size="1">2022-04-14 11:05 AM</font>
每一个 String值都有相关的索引类型， String.Index，它相当于每个 Character在字符串中的位置 #swift
<font size="1">2022-04-13 22:58 PM</font>
<hr>

字符串插值是一种从混合常量、变量、字面量和表达式的字符串字面量构造新 String值的方法 ,swift里用\(), ruby里用 ``  #swift
<font size="1">2022-04-13 22:57 PM</font>
<hr>

Swift 的 String类型是一种值类型 #swift
<font size="1">2022-04-13 22:55 PM</font>
<hr>

取消字符串中的转义  #"hello\nworld"#, 多个#也是可以的 ##"hello\nworld"## #swift
<font size="1">2022-04-13 22:52 PM</font>
<hr>

swift 多行字符串字面量跟python有点像  """ """ #swift
<font size="1">2022-04-13 22:48 PM</font>
<hr>

swift 区间运算符有点意思  a...b  ,指的是a到b包括ab, 注意是3个点, 半开区间运算符 a..<b,不包括b,很形象. 还有单侧区间,  for name in names[2...], for name in names[...2], 半开区间也可以有单侧形式 names[..<2] #swift
<font size="1">2022-04-13 22:46 PM</font>
<hr>

合并空值运算符  a ?? b   等价于  a != nil ? a! :b   如果可选项 a有值则展开,无值则返回默认值 b  #swift
<font size="1">2022-04-13 22:36 PM</font>
<hr>

do{ try fn()} catch{} swift中的异常捕获相对更好些.具体到能看到某个函数会引发异常,而不是像java 都在一个try中 #swift
<font size="1">2022-04-13 22:25 PM</font>
<hr>

do{ try fn()} catch{} swift中的异常捕获相对更好些.具体到能看到某个函数会引发异常,而不是像java 都在一个try中 .
<font size="1">2022-04-13 22:25 PM</font>
<hr>

user?.name  如果user不是nil就获取其name值 , user!.name 强制拆name值,如果nil,引发异常  #swift
<font size="1">2022-04-13 22:23 PM</font>
<hr>

swift中显示可选项 let name: String?  ,取值 的时候要使用 name! ,无值会异常.  隐式可选 项 let name: String! , 取值的时候不用!, 那跟let name: String还有什么区别呢? #swift
<font size="1">2022-04-13 21:59 PM</font>
<hr>

verbatim 一字不差
<font size="1">2022-04-13 17:43 PM</font>
<hr>

Text("hello") 和 var s= "hello"; Text(s)是不一样的 #swiftui
<font size="1">2022-04-13 17:43 PM</font>
<hr>

toast 显示的时间应该跟toast显示的文字的长度正相关  #设计 #swiftui 
<font size="1">2022-04-13 17:34 PM</font>
<hr>

Enable vim mode in Xcode 13 From the global top menu choose Editor > Vim Mode
<font size="1">2022-04-13 11:21 AM</font>

如果在一个 WindowGroup 里加入多个 View, 呈现状态有点类似 VStack。

在一个 Scene 中加入多个 WindowGroup，只有最前面的可以被显示。#swiftui
<font size="1">2022-04-12 23:13 PM</font>
<hr>

为了能够让开发者更好的掌控代码，同时也保持对于上一版本良好的兼容性，苹果在 SwiftUI2.0 中添加了@StateObject。顾名思义，它是@State 的引用类型版本。

在 WWDC 的视频中，苹果明确的表明@StateObject 是被创建他的 View 所持有的，也就是说，实例的生命周期是完全可控的，是同创建它的 View 的生命周期一样的。

@StateObject 和 @ObservedObject 的区别就是实例是否被创建其的 View 所持有，其生命周期是否完全可控。 #swiftui
<font size="1">2022-04-12 22:57 PM</font>
<hr>

@StateObject 和 @ObservedObject 的区别就是实例是否被创建其的 View 所持有，其生命周期是否完全可控 #swiftui
<font size="1">2022-04-12 22:56 PM</font>
<hr>

@State 只能用于当前视图，并且其对应的数据类型为值类型（如果非要对应引用类型的话则必须在每次赋值时重新创建新的实例才可以）#swiftui
<font size="1">2022-04-12 22:27 PM</font>
<hr>

在 SwiftUI 中，视图是由数据（状态）驱动的。按照苹果的说法，视图是状态的函数，而不是事件的序列（The views are a function of state, not a sequence of events）。每当视图在创建或解析时，都会为该视图和与该视图中使用的状态数据之间创建一个依赖关系，每当状态的信息发生变化是，有依赖关系的视图则会马上反应出这些变化并重绘。 #swiftui
<font size="1">2022-04-12 22:26 PM</font>
<hr>

demucs 运行前判断系统cpu多少核心 
<font size="1">2022-04-12 17:46 PM</font>
<hr>

from signalProcessing import get_chroma, \
                         chordgram,\
                         chord_sequence_filter,\
                         chord_sequence,\
                         chord_sequence_with_time  一个和弦识别软件中引用的库,不太准 #和弦识别
<font size="1">2022-04-12 10:31 AM</font>
<hr>

file.io 免费上传下载文件,一次性
<font size="1">2022-04-11 17:16 PM</font>
<hr>

<https://www.jianshu.com/p/c5d0bb6cf0eb>
<font size="1">2022-04-07 14:59 PM</font>
<hr>

PopOver With Arrows Using SwiftUI  #keyword
<font size="1">2022-04-06 20:16 PM</font>
<hr>

下载bilibili视频 <https://github.com/leiurayer/downkyi> 
<font size="1">2022-04-05 20:18 PM</font>
<hr>

Half Sheet Modal #swiftui #keyword
<font size="1">2022-04-02 16:08 PM</font>
<hr>

swiftUI 中的环境变量 首先需要声明,并且需要有一个入口注入.这个入口一般是view注入后,入口后面的view都将共享这个环境变量.如果是在App使用,要手动声明这个变量对象,APP入口文件使用这个对象变量,同时其他view需要使用,也需要将这个变量注入到你想要的入口view中.在view中需要做变量声明 #swiftui
<font size="1">2022-04-02 10:51 AM</font>
<hr>

test
<font size="1">2022-04-01 17:00 PM</font>
<hr>

在 SwiftUI 中，修饰符的功能类似于 CSS，用来在应用布局中定位和配置视图，如修改视图的大小、背景、添加动画、添加手势等等。View 协议通过扩展提供了大量的修饰符，它们以协议方法的形式给出，同时提供了默认实现。

修饰符的效果具有传递性，也就是说，父视图上使用的修饰符也会影响到其所有子视图，除非子视图显式的调用修饰符来覆盖这种效果。

之所以能以链式的方式调用修饰符，是因为每个修饰符方法的返回值是 some View （如frame() 的声明），仍然是一个视图，所以可以在新的视图的基础上继续调用修饰符。

需要注意的是，在链式调用的过程中，修饰符的顺序会对实际效果产生影响。相同的两个修饰符以不同的顺序调用，呈现的结果可能是不一样的。 #swiftui
<font size="1">2022-04-01 16:59 PM</font>
<hr>

每一个单独的 Modifier 并不会对 View 类型实例进行操作，而是一个返回 some View类型的闭包。因此 Modifier 的运行机制与我们熟悉的 UIKit 中对视图属性进行修改的方式是相反的，我们构建出一个视图时并不会先初始化出一个 View 实例再对其进行修饰，而是通过声明的各种Modifier 构建出View 实例
<font size="1">2022-04-01 16:52 PM</font>
<hr>

ffplay 播放中实时改变参数可以等价于新的参数从当前位置播放 #ffmpeg
<font size="1">2022-03-30 11:19 AM</font>
<hr>

oc中 block闭包默认对外面变量访问是变量的副本,如果需要修改外部变量,则需要在外部变量前加 __block,相当于block访问此变量的指针,因此可以改变变量,而不是默认的副本  #objc
<font size="1">2022-03-29 10:08 AM</font>
<hr>

aka是also known as缩写，指的是亦称、也被称为的意思
<font size="1">2022-03-29 09:46 AM</font>
<hr>

大七和弦和半减七, 大七根音升音音就是升的这个半音的半减七,因为大七升根相当于 357降了半音,正好是b3b5b7.  反之,半减七根音降半音相当于降的这个音的大七,因为b3 b5 b7升半音 357就是大七了. 这个在吉他上更明显一些 #弹琴
<font size="1">2022-03-26 07:51 AM</font>
<hr>

ffplay -af "volume=1.0,atempo=4.0" 1.mp3
<font size="1">2022-03-24 22:33 PM</font>
<hr>

转调分转调和变速两部分,先转调后转速质量好,反之则会丢失细节
<font size="1">2022-03-22 16:38 PM</font>
<hr>

ffmpeg ff是Fast Forward ,mpeg是Moving Picture Experts Group的缩写.(动态图像专家组)
<font size="1">2022-03-22 14:36 PM</font>
<hr>

未签名的macOS app启动时候会显示警告,这个警告可以通过安全中心打开后不再提示,如何让其再提示呢?  #问题
<font size="1">2022-03-22 14:00 PM</font>
<hr>

存储不压缩(-j参数不创建外层文件夹)  zip -0 -r -j  xxx.zip xxx
<font size="1">2022-03-21 14:14 PM</font>
<hr>

创建分卷压缩文件 zip -s 100m -r file.zip foo/
<font size="1">2022-03-21 13:51 PM</font>
<hr>

<https://api.iyk0.com/> 免费api
<font size="1">2022-03-21 10:50 AM</font>
<hr>

ffmpeg 取消控制台输出 后面加上 -loglevel quiet
<font size="1">2022-03-11 10:15 AM</font>
<hr>

终端代理设置一般使用 ALL_PROXY,但有时候也需要设置 https_proxy 
<font size="1">2022-03-10 15:56 PM</font>
<hr>


独立运行的python构建版本,最小化运行时依赖,<https://python-build-standalone.readthedocs.io/en/latest/>  #python #pyoxidizer
<font size="1">2022-03-10 14:33 PM</font>

mkv播放器可以选择首选音频语言
<font size="1">2022-03-09 21:56 PM</font>
<hr>

PyOxidizer python自包含打包应用
<font size="1">2022-03-09 17:51 PM</font>
<hr>

python自包含环境,绿色运行环境,可以独立运行python的绿色运行环境 Self-contained Python environment for Mac OS #python #standalone #关键字
<font size="1">2022-03-09 17:01 PM</font>
<hr>

python自包含环境,绿色运行环境,可以独立运行python的绿色运行环境 Self-contained Python environment for Mac OS #python #standalone
<font size="1">2022-03-09 17:00 PM</font>
<hr>

platypus 把python程序包装成独立的mac APP 
<font size="1">2022-03-09 16:39 PM</font>
<hr>

ffmpeg静态版 <https://evermeet.cx/pub/ffmpeg/>
<font size="1">2022-03-09 13:40 PM</font>
<hr>

找免费商业因音乐可以搜“creative commons music free”或“creative commons”查找支持知识共享的歌曲，进入歌曲详情查看具体的许可协议
<font size="1">2022-03-07 14:06 PM</font>
<hr>

ffmpeg -af 与complex-filter不可以同时使用
<font size="1">2022-03-07 10:49 AM</font>

ffmpeg中setTempo setRate setPitch的区别是什么 #ffmpeg
<font size="1">2022-03-05 20:40 PM</font>

<hr>

<https://tailwindcss.com/> 让不是很懂CSS的人能写出不那么丑的前端界面
<font size="1">2022-03-01 17:58 PM</font>
<hr>

<https://tailwindcss.com/>
<font size="1">2022-03-01 17:57 PM</font>
<hr>

B6 就是一个三和弦加了一个6音  #弹琴
<font size="1">2022-03-01 17:51 PM</font>
<hr>

属七和弦的变化引申音, b9 #9  #11 b13.  9可升降, 11只可升,因为降的话就是3了. 13只可降,因为升的话就是b7了,是和弦内音.  记忆的话就是降9是小2度,升9是小3度, 升11是增4度,降13就是小6度   #弹琴
<font size="1">2022-03-01 15:11 PM</font>
<hr>

属七和弦的变化引申音, b9 #9  #11 b13.  9可升降, 11只可升,因为降的话就是3了. 13只可降,因为升的话就是b7了,是和弦内音  #弹琴
<font size="1">2022-03-01 15:09 PM</font>
<hr>

大、小、属的引申音不受和弦性质影响,都一样 ,以根音为参照物,大二度是9,纯4度是11,大6度是13  #弹琴
<font size="1">2022-03-01 15:02 PM</font>
<hr>

demucs 3.0.4增加伴奏轨输出 
<font size="1">2022-03-01 14:48 PM</font>
<hr>

alt音阶是旋律小调的第七级音阶，所以，将alt音阶与旋律小调音阶结合起来记忆就方便多啦！ 从C旋律小调的第七级开始，即为B alt音阶 ，我们可以用在B alt 和弦上面！其他调的alt音阶，我们都可以从这个调主音上方小二度的旋律小调音阶推导出来！ #弹琴
<font size="1">2022-02-28 16:45 PM</font>
<hr>

键盘中音阶手指的分配 ,五声音阶一般就是3+2或是2+3, blues音阶(6个音),一般就是4+2或者3+3  #弹琴
<font size="1">2022-02-28 16:17 PM</font>
<hr>

两个系统,一个是看到一个和弦,有几种调式音阶可用 ,另一个是这个和弦是几级,确定用什么什么调的调式音阶  #弹琴
<font size="1">2022-02-28 16:15 PM</font>
<hr>

学习音乐过程中,听话比听懂话更重要
<font size="1">2022-02-28 16:13 PM</font>
<hr>

Blues大小调说法的由来

1	b3	4	b5	5	b7

6	1	2	b3	3	5

  1	2	b3	3	5	6	

#弹琴
<font size="1">2022-02-28 14:32 PM</font>
<hr>

blues12小节 1411-4411-5411, 后面都是411,小节前面分别是145 #弹琴
<font size="1">2022-02-28 14:16 PM</font>

roland td25 电鼓驱安装注意几点. 一是要在电鼓上设置驱动类型为 vendor,并且要重启电鼓,二是安装完驱动前不要连接电鼓,驱动安装后重启的时候要连接电鼓  #问题解决
<font size="1">2022-02-27 08:37 AM</font>

<hr>

DT770 Pro 250oml
<font size="1">2022-02-24 17:44 PM</font>
<hr>

先找到一个曲子里所有的属. 这些属极有可能就是251中的5  #弹琴
<font size="1">2022-02-23 11:37 AM</font>
<hr>

251,大调是 小、属、大, 小调是半减属小 #弹琴
<font size="1">2022-02-23 10:17 AM</font>
<hr>

键盘上7和弦第三转位要理解在三和弦在左边加一个7音 #弹琴
<font size="1">2022-02-22 21:56 PM</font>
<hr>

Toontrack EZmix 
<font size="1">2022-02-22 14:28 PM</font>
<hr>

spleeter或是demucs 分出来的 bass,drum,vocal 非常适合在live里进行midi转换 #弹琴
<font size="1">2022-02-22 10:11 AM</font>
<hr>

airpods 为啥连不上小米盒子?
<font size="1">2022-02-21 17:11 PM</font>
<hr>

sidechain ,根据一个(轨道)声音调整另外一个(轨道)声音 
<font size="1">2022-02-18 16:06 PM</font>
<hr>

很多时候其实一个人缺乏的是：在做事之前就能判断出这事能做大，还是不能做大
<font size="1">2022-02-18 13:32 PM</font>
<hr>

小米空气净化器上放macbook,当个超级静音散热风扇,电脑唤醒、待机是否可以触发散热风扇关闭开启?   #idea
<font size="1">2022-02-18 03:35 AM</font>
<hr>

调式音阶,比如Dorian是不是也可以就理解为  2 3 4 5 6 7 1, 而不一定要理解为 1 2 b3 4 5 6 b7,  这样在吉他上找音是不是会更容易? 以2为开始是不是应该人听觉上也不会以为1才是主音.  这个所谓的主音,到底 是听觉上的,还是符号层面的? #弹琴
<font size="1">2022-02-16 17:36 PM</font>
<hr>

即兴的两大思路.   一是以调为中心,也可以说是以音阶为中心,和弦为音阶服务. 另外一种思路是以和弦为中心, 针对某个和弦,可以跑不同调式的音阶(从调性上可能是不用调)  #弹琴
<font size="1">2022-02-16 09:43 AM</font>
<hr>

尸位素餐
/shīwèi-sùcān/
空占着职位，白吃饭不做事。
<font size="1">2022-02-16 09:04 AM</font>
<hr>

android电视盒子上的 KODI播放器功能非常强大, 播放MKV的时候可以指定默认语言的字幕和音频. 
<font size="1">2022-02-16 08:57 AM</font>
<hr>

每个调式音阶对应一类和弦, 这个跟大调和弦级数还有点对应关系, 1 4级是大七, 236级是小七,5级是属七. 7级是半减七.  调式音阶本来就是从大调音阶推导出来的. #弹琴 
<font size="1">2022-02-15 16:40 PM</font>
<hr>

每一个调式音阶对应一个和弦,主要看音阶中的3音和7音. 比如 Dorian. 1 2 b3 4 5 6 b7,对应的就是小七和弦, 像Lydian 1 2 3 #4 5 6 7 ,对应的就是大七和弦,其中#4并不需要理会. Mixolydian 1 2 3 4 5 6 b7,对应的是属七和弦. Locian 1 b2 b3 4 b5 b6 b7 这个肯定就是半减七和弦了. 所以看到一个大七和弦,可以弹 Ionian和Lydian, 小七可以弹Dorian,Phrygian  #弹琴
<font size="1">2022-02-15 16:37 PM</font>
<hr>

大小调思维中,音阶是老大,和弦跟着音阶走.调式思维中,和弦是老大,音阶是围绕着和弦来的 #弹琴
<font size="1">2022-02-15 16:00 PM</font>
<hr>

根音和五音是纯五度,五音可省略  #弹琴
<font size="1">2022-02-15 14:43 PM</font>
<hr>

三位音乐制作 人: 1.富田惠一 2.吴庆隆 3. 钟兴民
<font size="1">2022-02-15 10:31 AM</font>
<hr>

在1w左右预算你还能选择一个神级MIDI键盘，就是Doepher。这个深受好莱坞制作人青睐的牌子，自带锤感反馈系统，完全真实钢琴配种，可以选择带手提箱和不带手提箱的版本，不带手提箱的话，你就得自己组装了
<font size="1">2022-02-14 17:38 PM</font>
<hr>

豆瓣top250 和IMDB top250 里相同的电影有82部
<font size="1">2022-02-14 15:07 PM</font>
<hr>

对不起领导的忽悠
<font size="1">2022-02-14 11:45 AM</font>
<hr>

推荐 svelte+fastapi
<font size="1">2022-02-14 09:57 AM</font>
<hr>

degit做的事很简单，复制git仓库代码
<font size="1">2022-02-14 09:54 AM</font>
<hr>

进步与兴趣钟摆的中间点需要人主动发力推一把
<font size="1">2022-02-11 10:05 AM</font>
<hr>

米果,把加湿器打开
不要,我要加干
那不叫加干,叫除湿
'厨师',厨师是做菜的
@!@!?
#米果

<font size="1">2022-02-11 08:52 AM</font>
<hr>

音频跳线盒
<font size="1">2022-02-10 15:17 PM</font>
<hr>

react.js 之于next.js 和  vue.js之于nuxt.js   前者next.js中的e是react第二个字母,nuxt中的的u是vue中的第二个字母
<font size="1">2022-02-08 10:27 AM</font>

<hr>

专门生成静态网站(SSG)
<font size="1">2022-02-08 10:25 AM</font>
<hr>

Server-Side Rendering (SSR) Vs Client-Side Rendering (CSR)
<font size="1">2022-02-08 10:02 AM</font>
<hr>

饕餮 /Tāotiè/大餐
<font size="1">2022-02-08 09:04 AM</font>
<hr>

一个人推的最新文件名固定在年底的时候会因为同步造成上一年的内容也新一年的内容合并,解决办法第一年使用不同文件名 
<font size="1">2022-02-07 09:29 AM</font>
<hr>

mac上鼠标在窗口的位置,即使窗口不是焦点,也可以接收scroll消息, 而sharemouse,可以以屏幕为单位,接收消息. 
<font size="1">2022-02-06 22:03 PM</font>
<hr>

hibernatemode=0, macmini,iMac台式机默认参数,数据保留在内存, hibernatemode=3 macbook默认参数,数据保留在内存和硬盘 
<font size="1">2022-02-05 06:59 AM</font>
<hr>

一套键盘鼠标控制多台电脑软件 sharemouse
<font size="1">2022-02-02 17:49 PM</font>
<hr>

VEP  主从系统的关键软件：Vienna Ensemble Pro 6+一个加密狗 
<font size="1">2022-02-01 00:27 AM</font>
<hr>

komplete kontrol 预览音色音量在左下角 #ni
<font size="1">2022-02-01 00:16 AM</font>
<hr>


ln 目录时, 转义和双引号只用其一
<font size="1">2021-12-04 19:59 PM</font>
<hr>


md编辑器,还有Zettlr 和 Mark Text
<font size="1">2021-11-28 22:08 PM</font>
<hr>


和声分析工具 <https://xclient.info/> <https://xclient.info/>
<font size="1">2021-11-13 22:32 PM</font>

-运动健康记录管理
连接手环设备可查看用户步数和心率数据，给你多一份关爱。
<font size="1">2021-12-03 13:23 PM</font>

你不慌张了,青春就没了 --高晓松
<font size="1">2022-01-29 16:55 PM</font>
<hr>

前端的问题不是难，而是它面对最终用户。只要用户的喜好和口味发生变化，前端就必须跟上
<font size="1">2022-01-29 15:05 PM</font>
<hr>

音乐app应该增加个功能,点喜欢同时下载这首歌. #idea
<font size="1">2022-01-29 14:47 PM</font>
<hr>

Github Pages的server应该是跑在UTC时区下的，而 我所在的时区是北京时区，也就是UTC+8。在我今天发布的这篇博客里，所有的时间用的都是 UTC+8时区的本地时间。Github Pages估计只会编译server的当前时刻之前的文件. 解决办法就是将时间设置成前一天,gitpage就可以更新了 #gitpage
<font size="1">2022-01-29 14:29 PM</font>
<hr>

同样是清粥小菜, 饿的时候便会不同,天天鱼肉亦会不同
<font size="1">2022-01-26 17:37 PM</font>
<hr>

了不起的javascript读书笔记  <https://github.com/anbang/javascript-notes>  #书 
<font size="1">2022-01-26 13:30 PM</font>
<hr>
